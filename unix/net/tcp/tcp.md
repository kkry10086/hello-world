# TCP

## 流程：

1. (socket)创建监听套接字
2. (bind)绑定该套接字
3. (listen)监听该套接字，创建两个链接队列：已完成链接队列，未已完成链接队列。
4. (accept)接收链接请求。从已完成链接队列提取新的链接，创建一个新的链接套接字，
    使用这个已连接套接字和当前这个客户端通信
5. (read/write)收发信息
6. (close)关闭套接字

v

## accept:

**细节：**
<p><font color = 'red'>
tcp的三次握手，第一次握手是通过监听套接字完成的。
剩下的两次握手是通过新创建的套接字来通讯完成的。
</font></p>

**函数：**
int accept(int sockfd,struct sockaddr *addr,socklen_t *addrlen);
参数：
  sockfd:监听套接字
  addr:保存客户端地址信息结构体
  addrlen：结构体的大小的地址

**返回值：**
  success: 返回已连接套接字
  failed: 返回-1，errno is set appropriately




## 一些有用的拓展：

有时候，服务器的sercer SIGINT或者close(socket)，会导致再次开启server时，无法接收客户端的链接。


<h3><font color = "red">!!!非常重要，可以学习!!!</font></h3>


<p>
<strong><font color = "red">
实际上在发生上诉操作时，系统内核不会那么快的回收socket资源。
因为内核需要完成TCP的四次挥手来结束这次的链接，但是四次挥手中，谁最先发送FIN，
谁就要进入TIME_WAIT的状态，此时就要等待2MSL的时间。在这个时间内无法在接受新的连接。
此时，server再次运行就再次绑定了。这次的绑定是允许的。
</font>
</strong>
</p>


<p>
<strong>
<font color = "red">
reason：
  同一个套接字（同一个ip与port）是可以多次绑定的，套接字实质上就是在内存的一个栈。
</font>
</strong>
</p>

<p>
<strong>
<font color = "red">
  此时一旦有一个进程将套接字的状态改变，多个进程共用的栈空间就被修改了状态。
  假设SIGINT或close(socket)，那么内核要遵循TCP的四次挥手来结束链接。
</font>
</strong>
</p>

<p>
<strong>
<font color = "red">
  但是我们这边关闭了，而我们没有发送FIN报文给对方(SIGINT)，对方没有发送FIN报文给我们(socket)，这时我们的链接都存在着，却无法进行通信(无论接收)，只能等待TCP自己关闭，要等待一段时间，这时该socket才能再次使用。
</font>
</strong>
</p>

## 

## 半关闭

当a发送了FIN之后就处于半关闭，（此时是在应用层实现了关闭写端，在底层没有关闭写端。）【这里应用层实现了关闭写端，是指现象，并不是指在应用层用命令关闭了写端】
等到a经历了FIN_WAIT1,FIN_WAIT2,TIME_WAIT,2MSL状态后才是真正的关闭。

注意：这里的应用层实现了半关闭实际上是由底层来实现的。实际上后面为了回复对方的FIN报文，实际上还需要返回ACK报文。


如何在应用层用命令实现关闭写端或读端

使用shutdown()函数。

## 心跳包

keepAlive = 1;

setsockopt(listenfd,SOL_SOCKET,SO_KEEPALIVE,(void *)&keepALive,sizeof*(keepAllive));

SO_KEEPALLIVE：
抱持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方发一个保持存活探测分节(keepalive probe)。这是一个对方必须响应的TCP分节。

会导致以下三种情况：
```
1. 对方接收，一切正常：以期望的ACK响应。
2. 2小时后，TCP将发出另一个探测分节。对方已崩溃且已重新启动：以RST响应。套接口的
   待处理错误设置为ECONNRESET，套接口本身则被关闭。
3. 对方无任何响应：源自berkeley的TCP发送另外8个探测分节，相隔75秒一个，试图得 
   到一个响应。在发出第一个探测分节之后（由于总共9个探测分节）9*75=11分15秒，没
   有响应就放弃，套接口的待处理错误设置为ETIMEOUT，套接口本身则被关闭。

```
系统自带的没卵用，因为两个小时太久了。也很少用。
这个一般都是自己写的。


## 多路IO转接技术（非常重要！！！）

### 阻塞等待（accept和read默认都是带阻塞的）
来一个客户请求才处理，这种方式实现兵法，大多书时间，我们的进程或线程大多时间都处于空闲状态。
非常浪费内存的资源。


### 非阻塞忙轮询
只有一个进程（有很多的套接字），不停地访问每一个套接字，查看是否有链接或数据到达。
这样的方式非常的浪费cpu资源。


### io复用/多路io转接技术

监听多个文件描述符的读写缓冲区的变化（设备文件的文件描述符）。
只需使用一个进程。
监听到的文件描述符分两类，一种是监听的，一种是交互的。
