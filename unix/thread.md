#  线程

## 一、 线程概念
许多经典的操作系统教科书中，总是把进程定义为程序的执行实例，它并不执行什么，只是维护在应用程序所需的各种资源，而线程则是真正的执行实体。
所以线程是轻量级的进程（LWP：light weight process），在Linux环境下线程本质仍是进程。
为了进程完成一定的工作，进程必须至少包含一个线程。
|<font color=Red >进程</font>|
|:-:|
|<font color=Red >线程A栈</font>|
|<font color=Red >线程B栈</font>|
|堆区|
|BSS区|
|数据区|
|代码区|


<font color=Red >注意：</font> 
<font color=Red >1. 进程是CPU分配资源的最小单位</font>
<font color=Red >2. 线程是CPU调度的最小单位</font> 


## 二、线程特点

1. 线程也有PCB，创建线程(pthread_create)和创建进程(fork)的底层函数都是clone()。
2. 从内核里看，线程与进程是一样的，各自有不同的PCB，因此线程又是轻量级进程。
3. 进程可以蜕变成线程。

### 1.线程与进程在实现上的区别

: 如果**复制**对方的地址空间，就会产生一个<font color=Red>进程</font>
: 如果**共享**对方的地址空间，就会产生一个<font color=Red>线程</font>

Linux是不区分进程与线程的，只在用户层面上作出区分。

##  三、线程共享资源

1. 文件描述符表
2. 每种信号的处理方式
3. 当前工作目录
4. 用户ID与组ID
5. 内存地址空间（.txt/.bss/.data/heap/共享库）


## 四、线程非共享资源

1. 线程ID
2. 处理器现场和栈指针（内核栈）
3. 独立的栈空间（用户空间栈）
4. errno变量
5. 信号屏蔽字
6. 调度优先级

## 五、线程的优缺点

### 1.优点
提高程序并发行
开销小
数据通信，共享数据方便

### 2.缺点
库函数不稳定
测试、编写困难，GDB不支持
对信号支持不好


## 六、线程常用操作：
### 6.1 线程号


## 七、线程分离
一般情况下，线程终止后，其终止状态一直保留到其他线程调用pthread_join获取它的状态为止。但是线程也可以被设置为detach状态，这样的线程一旦终止就立刻回收它占用的所有资源，而不保留终止状态。

不能对一个已经处于detach状态的线程调用pthread_join，这样的调用将返回EINVAL错误。

线程分离的目的就是让回收线程资源的工作交由系统来自动完成。所以线程不会被阻塞。



### 7.1 线程退出

进程退出可以使用exit()或_exit()，在一个线程中我们可以通过以下三种在不终止整个进程的情况下停止它的控制流。

1. 线程从执行函数中返回；
2. 线程使用pthread_exit退出线程；这个方法与上面是相同的；
3. 线程可以被同一进程中的其他线程取消(pthread_cancel|pthread_kill)；

pthread_cancel：并不是立刻的，而是有一定的延时的，需要等待线程到达某个取消检查点。
取消点：粗略认为一个系统调用（进入内核）为一个取消点。 



## 八、线程属性

pthread_attr_t结构体。


属性值布不能直接设置，需用相关的函数进行操作。使用pthread_attr_init初始化，之后必须使用pthread_attr_destory销毁。

## 注意事项：

```
1. 主线程退出其他线程不退出，主线程应调用pthread_exit。
2. 避免僵尸线程：
  1）pthread_join
  2）pthread_detach
  3）pthread_create设置分离属性
3. malloc和mmap申请的内存可以被其他线程释放
4. 应避免在多线程模型中调用fork，除非马上exec，子进程只有调用fork的线程存在，其他线程在子进程中都pthread_exit退出了
5. 信号的复杂语义很难和多线程共存，避免在多线程中引入信号机制

```

