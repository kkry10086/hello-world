# 线程的同步问题

## 一、互斥锁

### 1.1 同步与互斥

```
. 都需要访问/使用同一种资源
. 多个任务之间有依赖关系，某个任务的运行依赖于另一个任务。
```
这些是多任务变成遇到的最基本问题，同时也是核心问题。
同步与互斥就是用来解决这些问题的。


**互斥**：是指散布在不同任务之间的若干程序片段，当某个任务运行其中一个程序片段时，其他任务就不能运行他们之中的任一程序片段，只能等到该任务运行完这个程序片段后才可以运行。

**同步**：是指散布在不同任务之间的若干程序片段，他们的运行必须严格按照规定的某种先后次序来运行，这种先后次序依赖于要完成的特定的任务。

可以说同步是一种特殊的互斥。互斥也是一种特殊的同步。互斥具有唯一性和排他性。


### 1.2 互斥锁


### 1.3 互斥锁Mutex介绍

线程里有一把锁：互斥锁（Mutex），也叫互斥量。互斥锁时一种简单的加锁的方法来控制共享资源的访问。互斥锁只有两种状态：加锁与解锁。

**互斥锁的操作流程**：
1. 在访问共享资源后，临界区域前，对互斥锁进行加锁
2. 在访问完成后时方互斥锁上的锁
3. 在互斥锁进行加锁后，任何其他试图再次对互斥锁加锁的线程都会被阻塞，直至锁被释放

**互斥锁类型**：pthread_mutex_t

初始化函数：pthread_mutex_init()
销毁函数：pthread_mutex_destroy()
加锁函数：pthread_mutex_lock()一旦失败就阻塞，直至成功；或者 pthread_mutex_trylock()一旦失败就直接运行下去。
解锁函数：pthread_mutex_unlock()



### 1.4 死锁
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或彼此通信而造成的一种阻塞现象。若无外力作用，他们都将无法推进下去。此时称系统产生了死锁或系统处于死锁状态，这些永远在互相等待的进程称为死锁进程。

#### 1.4.1 死锁产生的原因
1. **竞争不可抢占资源引起死锁：**
即多个进程在等待的资源已经被抢占，且由于被抢占导致所有的进程都无法进行，资源也就无法解锁，这样就无法进行下去

2. **竞争可消耗资源引起死锁：**
有p1,p2,p3三个进程，p1向p2发送消息并接受p3发送的信息，p2向p3发送消息并接受p1发送的信息，p3向p1发送消息并接受p2发送的信息。如果设置是先接受消息再发送消息，则所有的消息都无法发送，这就造成了死锁。


#### 1.4.2 死锁的必要条件

1. **互斥条件：**
: 某资源只能被一个进程使用，其它进程请求该资源时，只能等待，指导资源使用完毕后释放资源。
2. **请求和保持条件：**
: 程序已经保持了至少一个资源，但是又提出了新要求，而这个资源被其他进程占用，自己占用资源却保持不放。
3. **不可抢占条件：**
: 进程已获得的资源没有使用完，不能被抢占
4. **循环等待条件：**
: 必然存在一个循环链


#### 1.4.3 处理死锁的思路
**预防死锁**
  破坏死锁的四个必要条件中的一个或多个来预防死锁。
**避免死锁**
  在资源动态分配过程中，用某种方式防止系统进入不安全的状态。
**检测死锁**
  运行时出现死锁，能及时发现死锁，把程序解脱出来。
**解除死锁**
  发生死锁后，解脱进程。通常撤销进程，回收资源，再分配给正处于阻塞状态的进程。


#### 1.4.4 预防死锁的方法：

**破坏请求和保持条件：**
协议1：
  所有进程开始前，必须一次性地申请所需的所有资源，这样运行期间就不会再提出资源要求，破坏了请求条件。即使有一种资源不能满足要求，也不会给它分配正在空闲的资源，这样它就没有了资源，破坏了保持条件，从而预防死锁的产生。
  
协议2：
  允许一个进程获得初期的资源就开始运行，然后再把运行完的资源释放出来，然后再请求新的资源。
  
**破坏不可抢占条件：**
  当一个已经保持了某种不可抢占资源的进程，提出新资源请求不能满足时，它必须释放已经保持的所有资源。以后需要时在重新申请。
  
**破坏循环等待条件**
  对系统中的所有资源进行线性排序，然后规定每个进程必须按序列号递增的顺序请求资源。




## 二、读写锁

### 2.1 概述：
  在对数据的读写操作中，写操作较少，更多的是读操作。可是当使用互斥锁时，连读操作也被阻塞，因此为了满足当前能够允许多个读出，但只允许一个写入的需求，线程提供了读写锁来实现。
  
**读写锁的特点：**
1. 如果有其他线程读数据，则允许其他线程执行读操作，但不允许写操作。
2. 如果有其他线程写数据，则其他线程都不允许读、写操作。

**读写锁可以分为读锁和写锁：**
1. 如果某线程申请了读锁，其他线程可以再申请读锁，但不能申请写锁。
2. 如果某线程申请了写锁，其他线程不能申请读锁，也不能申请写锁。

POSIX定义的读写锁的数据类型是： pthread_rwlock_t
使用方式与pthread_mutex_t类似。


### 2.2





## 三、条件变量


