我们的程序想要运行，需要三样东西：
1.  硬件：　　执行程序且呈现的硬件．
2.　内核管理：操作系统的内核可以支持这个芯片组，当然还需要提供芯片的驱动程序．
3.　应用程序：我们要执行命令．

　　　我们的程序要让内核（kernel）的管理工作来让硬件执行，可是，我们是如何让内核工作
　　　的？我们可以通过shell将我们输入的命令与内核沟通，让内核可以控制硬件来正确无误
　　　地工作．
　
　　　shell意思为壳，意义是覆盖在内核之上的外壳，在最外层．
　　　操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动监测，如果
　　　这组软件能被用户随意操作，若用户应用不当，将会使得整个系统崩溃．
　　　但是我们总是需要让用户使用操作系统，所以就有了在操作系统上面发展的应用程序．
　　　这样用户就不会可以通过应用程序来指挥内核，让内核完成我们所需要的硬件任务．
      shell的功能只是提供用户使用操作系统的一个界面，可以执行其他的命令，例如
      mk,rm,man,vim等．

　
10.1.2为何学习shell?几乎所有的linux发行版使用的bash(shell的一种)都是一样的．
　　　而像XWindow之类的工具，在某些时候，例如升级或是使用其他程序管理模块时，会造成
　　　设置上的困扰．

　　　远程管理：
　　　此外，Linux的管理常常需要通过远程联机，此时命令行模式传输速度一定比较快，而且
　　　较不容易出现掉线或是信息外流的问题．

　　　
　　　Linux的任督二脉：shell
      良好的shell程序编写对于管理主机是一定需要的．


　　　10.1.3　系统的合法shell与/etc/shells功能：
　　　linux使用的一种版本的shell称为［Bourne Again SHell］bash.
      /etc/shells里面就有数种我们可以使用的shells,包括/bin/sh.
      这个文件的意义：系统的某些服务在运行过程中，会去检查用户能够使用的shells,而
      这些shell的查询就是借由/etc/shells这个文件．
　　　某些FTP网站回去检查用户可用的shell,而如果你不想要让这些用户使用FTP以外的
　　　主机资源时，可能会给予该用户一些怪怪的shell，让用户无法以其他服务登录主机．
　　　此时，你就会将该shell类型写入/etc/shells中．

　　　我们用户会使用那个shell来使用呢？这好似可以通过/etc/passwd这个文件每个
　　　用户的最后来得到．


     10.1.4 Bash shell 的功能：
     history：
     能够记录你使用过的命令，这些命令一般记录在使用者的家目录的.bash_history里面．
     不过，当前登录的命令都放置在内存中，只有当你注销账户后，才会写入到.bash_histor
     y里面．

　　　命令与文件补全功能：[TAB]

      命令别名设置功能：(alias)
      例如：alias ll='ls -al'
      
      任务管理，前台，后台控制：（job control,foreground,background）

      程序化脚本（shell scripts）：
      shell scripts可以将我们平时管理系统常需要执行的连续命令写成一个文件，该文件
      并且可以通过交互式的方式来进行主机的检工作，也可借由shell提供的环境变量及相关
      命令来进行设计．

　　　
　　　通配符：（Wildcard）
      除了完整的字符串，还支持通配符帮助用户查询与命令执行．
      
　　　　
　　　10.1.5　查询命令是否为Bash shell 的内置命令：　type
     　example：type [-tpa] name
     -t　：当加入时，将name以下面这些字眼显示出它的意义:
           file：外部命令
	   alias：该命令为其他命令的别名
	   builtin：该命令为bash的内置命令
     　　　
     -p　：如果后面接的name为外部命令时，才会显示完整的文件名
     -a　：会由PATH变量定义的路径中，将所有含name的命令都列出来，包括alias

　　　
      10.1.6命令的执行与快速编辑按钮：
      ctrl+u/k向前/后删除命令行．
      ctrl+a/e光标移动到开始/结束位置．



10.2shell 的变量功能：
　　　
　　　1.变量的可变性与方便性
　　　2.影响bash环境操作的变量
　　　　例如：PATH,所有的命令就是通过它来查找的，并使用的．
　　　3.脚本程序设计：
　　　　大型脚本中，变量可以保存一些需要经常使用或者修改的数据，那么就可以减少
　　　　shell scripts的修改了．

      10.2.2 变量的使用与设置：echo，变量设置规则，unset
      变量的设置与规则：
      用=来链接
      等号两边不能直接接空格
      变量名称只能是英文与数字，且开头只能是英文
      变量的内容若有空格，需要使用""包住
      只有双引号里面的$才有使用变量的含有，单引号没有．
      反单引号也有与$相似的功能，只有命令的功能
      export 可以将变量转变为环境变量：export name
      取消变量的方法为使用unset: ［unset 变量名称］
      进入内核模块：
      cd /lib/modules/`uname -r`/kernel
      cd /lib/modules/$(uname -r)/kernel


      10.2.3 环境变量的功能：
      使用env/export来查看我们有多少环境变量．
      结果中的变量含义：
      HOME　：用户的根目录．
      SHELL　：我们使用的shell是哪个程序
      HISTSIZE　：history记录的命令的条数由这个来决定
      MAIL　：邮箱文件读取时，使用到的变量名．
      PATH　：执行文件查找的路径
      LANG　：语系数据，
      RANDOM　：随机数的变量，现在的linux都有随机数生成器，在/dev/random这个文件．
      　　　　　
      用set观察所有变量：
      bash不只有环境变量，还有一些与bash操作界面有关的变量，以及用户自定义的变量。
      基本上，前两种变量设置为大写字母，一般为系统内定需要的变量。
      
      PS1：（提示字符的设置）
      PS1是命令提示字符，当你使用bash时，每一行前面的提示user，hostname，workspace
      等等，就可以用这个来设置。
      \d:显示日期
      \H:完整的主机名
      \h:仅取主机名在第一个小数点之前的名字
      \t:显示时间，24小时制
      \T:显示时间，12小时制
      \A:显示时间，24小时制，没有秒
      \@:显示时间，12小时制，am/pm
      \u:当前用户的账号名称
      \v:BASH的版本信息
      \w:显示完整工作目录名称
      \W:利用basename函数获得工作目录名称，仅会列出最后一个目录名
      \#:执行第几个命令
      \$:提示字符，如果是root就是#，否则是$
      
      $:（关于本shell的PID）
      $是shell的PID的变量，可以通过echo $$得到
      
      ？：（关于上个命令的返回值）
      当我们执行某个命令后，这些命令都会返回一个执行后的代码。一般来说，成功了，
      就是0，其他的情况，非0.
      
      OSTYPE,HOSTTYPE,MACHTYPE（主机硬件与内核的等级）
      
      export：（自定义变量转化为环境变量）
      环境变量与自定义变量的差异在于【该变量是否会被子进程所继续引用】。
      bash是一个独立的进程，这个进程的识别使用的是进程标识符，也就是PID。
      而你在这个bash下执行的任何命令都是有这个bash所衍生出来的，那些被执行
      的命令就被成为子进程。
      子进程仅会继承父进程的环境变量，子进程不会继承父进程的自定义变量。
      export就可以将自定义变量转化为环境变量。
      本质上是共享自己的变量设置给后来调用的文件或其他进程。例如，使用主文件
      调用其他附属文件时，可以用export将变量的设置只在主文件做一次。
      export name
      只使用export，择类似于env


     10.2.4影响显示结果的语系变量（locale）
     系统默认的语系定义在/etc/locale.conf
     
     10.2.5 变量的有效范围
     为何环境变量的数据可以被子进程所引用？
     。当启动一个shell，操作系统会分配一个内存区域给shell使用，此内存中的变量可以
       让子进程使用
     。若在父进程利用export的功能，可以让自定义变量的内容写到上述的内存区域当中
     。当加载另一个shell时（启动子进程），子shell可以将父shell的环境变量所在的内
       存区域导入自己的环境变量区块当中。


     10.2.6 变量键盘的读取、数组与声明：read、array、declare
       1.read:
         要读取来自键盘输入的变量，用read命令。最常见与shell scripts的编写当中。
	 这个命令可以与用户交互。
	 read [-pt] variable
	 -p ：后面接提示字符（提示语句将会被显示出来）
	 -t ：后面可以接等待的秒数
	 
       2.declare,typeset
          declare或typeset是一样的功能，就是声明变量的类型．
	  decleare [-aixr] variable
	  -a　：将后面名为variable的变量定义为array类型
	  -i　：将后面名为variable的变量定义为integer类型
	  -x　：用法与export一样，就是将后面的variable变为环境变量
	  -r　：将变量设置成为readonly类型，该变量不可被改变内容，也不能unset．
	  　　　也不能修改readonly的类型，只有注销再登陆才能恢复．

          important:
	  1.变量类型默认是字符串，所以整形是要-i来指定变量类型;
	  2.bash环境中的数值计算，默认最多仅能到整数形态，所以1/3结果是0；
	  　argument(参数)前面变为+变为取消．
	  
       3.array（变量类型）
       数组的设置方式：
       var[index]=content
       读取建议使用${var[index]}


　　　10.2.7　与文件系统及程序的限制关系：ulimit
      linux是多人多任务的系统，我们要考虑到各种可能的情况：假设有十几个人同时
      登陆，同时打开多个文件．假设一个人打开的文件占用内存大小至少为1Ｇ，此时
      电脑内存就要有20Ｇ才行，现实中内存没有可能每个电脑都做到那样．
      因此我们要限制用户的某些系统资源，包括可以打开的文件数量，可以使用的
      cpu时间，可以使用的内存总量等．

　　　ulimit:
      ulimit [-SHacdfltu] [配额]
      -H：hard limit,必定不能超过这个值
      -S：soft limit,可以超过这个设置值，但是超过则有警告信息
      -a：后面不接任何选项与参数,可列出所有的限制额度
      -c：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件（除错用）
      　　，这种文件就被称作内核文件（core file）．此为限制每个内核文件的最大容量．
      -f：此shell可以建立的最大文件容量，单位为2kbytes.
      -d：此程序可使用的最大段内存（segment）容量．
      -l：可用于锁定（lock）的内存量．
      -t：可使用的最大cpu时间（单位为秒）
      -u：单一使用者可以使用的最大进程（process）数量．


   10.2.8　变量内容的删除，取代与替换．
   　　1.变量内容的删除与替换：
   　　　可以自己试试，不过别用环境变量．
         ${variable#/name}
	 ${variable%:name}
	 #代表从前面开始删除，到name，由于最前面是/,所以是/
	 %/#代表最短，
	 %%/##代表最长
	 %代表从后面开始删除，到name,由于最后面是:,所以是:

         替换：
	 ${variable/name1/name2}
	 两个/之间就是要替换的旧字符串．后面的name2就是替换的新字符串．
	 只替换最先一个
	 若是${vaariable//name1/name2},就是全部替换．

         new var=${old var-content}这个是赋值的，只有当var还没有赋值时可以使用，
	 就连空字符串也没法用．
	 但是空字符串可以使用new var=${old var:-content}来赋值．

         若-变为+,那么就会反过来，只有在var已经赋值/var是空字符串才可以赋值，
	 其他情况不可以．
	 var=${str[:]+expr}
	 var=${str[:]=expr}
	 var=${str[:]?expr}
	 这里还是自己实操比较好．


   10.3 命令别名与命令历史
   　10.3.1　命令别名设置：alias,unalias
      当你要使用的命令非常长时，可以用alias取别名．
      另一种方法是，使用shell script
      alias用法：alias str1='str2'
      本质是创造一个新的命令．
      取消别命：unalias
      用法：unalias str1
      
   　10.3.2　历史命令history
      history [n]
      history [-c]
      history [-raw] histfiles