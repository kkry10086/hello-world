1.磁盘与目录的容量：
   df：列出文件系统的整体磁盘使用量；
   du：查看文件系统的磁盘使用量;

   df：主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要都是在
       超级区块内的信息，所以这个命令显示结果的速度非常快。

   du：du会直接到文件系统内区查找所有的文件数据，所以du所用时间会较长。

2.硬链接和符号（软）链接：ln
   链接文件有两种：一种是类似windows的快捷方式，可以让你快速连接到目标文件；
   另一种是通过文件系统的inode链接来产生新文件名，而不是产生新文件，这种称为
   硬链接。
   
   .硬链接：
     文件名只与目录有关，但是文件内容则与indoe有关；因此，多个文件名可以对应
     到多个inode；硬链接只是某个目录下新增一条文件名连接到某inode号码的关联
     记录而已。(如果不理解，那么就去看file_system.md)
     限制：不能跨文件系统；不能链接目录；
	 example：假设我在/kkk建立/etc的硬链接,那么/etc的文件都要链接到/kkk，
	          那么/etc有改变，那么/kkk也要进行再一次链接。这将造成相当大
		  的环境复杂度。


   .符号链接（symbolic link）：
     符号链接就是建立一个独立的文件，而这个文件会让数据的读取指向它链接的那个
     文件的文件名。与硬链接不同，符号链接的文件与被链接文件的inode不同。
     链接文件的重要内容就是他会写上目标文件的文件名。
   ln [-sf] source-file destination-file
   -s：不加参数就是硬链接，加了-s就是符号链接；
   -f:如果文件目标存在，就主动将目标文件删掉后再创建。（谨慎使用，最好不用）


三、磁盘的分区、格式化、校验与挂载：
   如果我们想要在系统里新增一块磁盘时，需要的操作：
   .对磁盘进行划分，以建立可用的硬盘分区；
   .对该硬盘分区进行格式化（format），以建立系统可用的文件系统；
   .若想要仔细一点，则可对刚刚建立好的文件系统进行校验；
   .在Linux系统上，需要建立挂载点，并将它挂载上来。


   1.观察磁盘分区状态：
  （1） lsblk【list block device】列出系统上的所有磁盘列表。
   输出的信息：
   NAME:就是设备的文件名，会省略/dev等前导目录
   [MAJ:MIN]：其实内核识别的设备都是通过这两个代码来实现的，分别是主要与次要
               设备代码；
   RM:是否为可卸载设备（removable device），如光盘，usb等；
   SIZE:容量；
   RO:是否为只读设备；
   TYPE:是磁盘（disk）、分区（partition）还是只读存储器（rom）等；
   MOUNTPOINT:挂载点。

   （2）blkid列出设备的UUID等参数：（root）
   lsblk -f 可以列出；
   UUID是全局唯一标识符（universally unique identifier），Linux会将系统内的
   所有的设备都给予一个独一无二的标识符，这个标识符可以拿来作为挂载或是使用这个
   设备或者文件系统。

    （3）parted列出磁盘的分区表类型与分区信息：
    parted device-name print

四、磁盘分区：gdisk和fdisk：
   用GPT举例：
   gdisk device-name对device进行分区；
   device-name后面不要加数字，磁盘分区是对整个磁盘分区，而不是某个分区。
   （1）用gdisk新增分区：自己看用man
   （2）partprobe更新Linux内核的分区表信息
   partprobe [-s] 不加s屏幕就不会出现信息。
   万分注意：不要去处理一个正在使用的分区（挂载）。假设，你已经使用了/dev/sda1.
   如果你要删除它，那么就必须先将/dev/sda1卸载，否则直接删除该分区的话，虽然
   磁盘还是会写入正确的分区信息，但是内核会无法更新分区表的信息。
   
五、磁盘格式化：
   mkfs（make filesystem）这个命令会调用正确的文件系统格式化工具软件。
   格式化就是创建文件系统
   创建XFS文件系统：mkfs.xfs
   mkfs.xfs　[-b bsize] [-d parms] [-i parms] [-l parms] [-L label] \
   [-f] [-r parms] 设备名称

   -b：后面接的是区块容量，可由512到64K，但是linux最多支持4K
   -d：后面接的是重要的data section的相关参数
   -i：与inode有较相关的设置
   -f：假设分区已有文件系统，则需要用-f来强制格式化
   -L：后面接文件系统的表头名称Label name
   -r：制定realtime section的相关设置值，常见的有：extsize=num
       设置extent的数值。

   Xfs文件系统for RAID性能优化（optional）：
   RAID（磁盘阵列）就是多块的磁盘组成一块大磁盘的意思，利用同步写入到这些磁盘
   的技术，不但可以加快读写速度，还可以让某一块磁盘坏掉时，整个文件系统还是可
   以持续运行，这就是容错。
   基本上RAID就是通过将文件先细分成数个小型的分区区块（stripe）之后,然后将
   众多的stripes分别放在磁盘阵列里面的所有磁盘，所以一个文件是被同时写入到
   多个磁盘中的，当然性能会好一点。为了文件的安全性，所以在这些磁盘中，会保
   留数个（与磁盘阵列的规划有关）校验磁盘（parity disk），以及可能会保留一
   个以上的备用磁盘（spare disk），这些区块基本上会占用掉磁盘阵列的总容量，
   不过对于数据的安全比较有保障。
   最好等到学完了14章再来看。


   
   mkfxs.ext4 [-b size] [-L label] 设备名称
   -b：设置区块大小
   -L：后面接设个设备的标头名称


五、文件系统校验：
  通常只有身为root且文件系统有问题的时候才使用这个命令，否则在正常情况下使用
  此命令，可能会造成对系统的危害。
   （1）xfs_repair处理XFS文件系统：
   xfs repair [-fnd] 设备文件：
   -f：后面的设备其实是个文件而不是实体设备
   -n：单纯检查并不修改文件系统的任何数据
   -d：通常用在单人维护模式下面，针对根目录（/）进行检查与修复的操作，很危险，
       不要随便使用。

   限制：修复文件系统时，该文件系统是不能被挂载的。只有先卸载了，才能检查。
         但是（/）是不能被卸载的，所以当/有问题时，要进入单人模式，使用-d
	 这个选项来处理。加入-d这个选项后，系统会强制检验该设备，检验完毕后
	 就会自动重新启动。

   （2）fsck.ext4处理ext4文件系统：
   fsck.ext4 [-pf] [-b superblock] 设备名称
   -p：当文件系统在修复时，若有需要回覆y的操作时，自动回覆y来继续进行修复操作；
   -f：强制检查，一般来说，如果fsck没有发现任何unclean的标识，不会主动进入详
       细检查的，如果你想要强制fsck详细检查，就用-f；
       
   -D：针对文件系统下的目录进行最佳化配置；
   -b：后面接超级区块的位置，一般用不到。但是如果超级区块损坏了，通过这个参数
       即可利用文件系统内备份的超级区块来尝试回复，一般来说，超级区块备份在：
       1K区块放在8193,2K区块放在16384,4K区块放在32758


六、文件系统的挂载与卸载：
要求：
    .单一文件系统不应该被重复挂载在不同的挂载点（目录）中；
    .单一目录不应该重复挂载多个文件系统；
    .要作为挂载点的目录，理论上应该都是空目录才行。

    当目录下面有文件，此时挂载了文件系统之后，原目录下的东西就会暂时消失。
    其实是被影藏了。等到卸载了文件系统后，原本的内容就会再次出现。
    （1）mount:
    mount -a
    mount [-l]
    mount [-t 文件系统] LABEL='' 挂载点
    mount [-t 文件系统] UUID='' 挂载点
    mount [-t 文件系统] 设备文件名 挂载点
    -a ： 依照配置文件/etc/fstab 的数据将所有未挂载的磁盘都挂载上来。
    -l ：单纯地输入mount会显示目前挂载的信息，加上-l可增列LABEL名称。
    -t ：可以加上文件系统种类来指定欲挂载地类型，常见地有xfs，ext3，4等。
    -n ：在默认情况下，系统会将实际挂载的情况即时写入/etc/mtab，以利其他
         程序运行。

   -o ：接一些挂载时额外加上的参数，比如说账号，密码，读写权限等。


    /etc/filesystems：系统指定的测试挂载文件系统类型的优先级；
    /proc/filesystems：Linux系统已经加载的文件系统类型。



     Linux支持的文件系统的驱动程序都写在如下目录里：
     /lib/modules/$(uname -r)/kernel/fs/

     .光驱一般为：/dev/sr
     光驱一旦挂载，就无法退出光盘。除非你将它卸载。

     .挂载vfat中文移动磁盘（usb磁盘）：
     blkid 得到UUID
     生成挂载点
     mount -o codepage=950,iocharset=utf8 UUID="num" 挂载点
     我们在挂载时，usb如果时中文文件名的数据，那么可以在挂载时指定文件系统
     所使用的语系。可以在man mount查到：codepage来选择语系，iocharset指定
     Unicode时utf8还是Big5。

     .重新挂载根目录与挂载挂载不特定目录：
     整个目树最重要的就是根目录，所以根目录根本就不能够被卸载。问题是，如果
     /的参数要改变，或是根目录出现只读的状态时，如何重新挂载？一个方式是
     重启，当然也可以像下面一样：
     mount -o remount,rw,auto /
     remount 要求重新挂载，这是个非常重要的机制。尤其是当你进入单人维护模式，
     你的根目录经常会被系统挂载为只读，这时候这个命令就太重要了。
     
     另外，我们还可以使用mount来将某个目录挂载例外一个目录。这并不是挂载文件
     系统，而是额外挂载某个目录的方法。虽然下面的方法也可以使用符号链接来做
     链接，不过在某些不支持符号链接的程序运行中，还是要通过这样的方法才行。
     这里有一点与使用符号链接不同给，就是两个文件的inode是相同的，但是本质还是
     符号链接。



   （二）umount（将文件系统卸载）
   umount [-fn] 设备文件名或挂载点
   -f：强制卸载，可用在类似网络文件系统（NFS）无法读取到的情况中；
   -l：立即卸载文件系统，比-f还要强；
   -n：不跟新/etc/mtab的情况下卸载。


七、磁盘/文件系统系统参数自定义：
   修改目前文件系统的一些相关信息，例如Label name，journal等等。
   （1）mknod：
   Linux下面的所有设备都是以文件来表示，而这就是统统major和minor数值来替代。
   通过ls -l查看磁盘设备，可以看到有主要设备代码（major）和次要设备代码（minor）；
   我们的Linux内核支持的设备数据就是通过这两个数值来决定的。
   在某些情况下，我们是需要手动处理设备文件的，例如，某些服务被chroot到特定目录下，
   就需要这么做。
   mknod 设备文件名 [bcp] [major] [minor]
   b：设置设备名称成为一个外接存储设备文件，磁盘；
   c：设置设备名称成为一个外接输入设备文件，鼠标，键盘；
   p: 设置设备名称成为一个FIFO文件。
   major：主要设备代码
   minor：次要设备代码



   （2）xfs_admin修改xfs文件按系统的UUID与Label name:
   xfs_admin [-lu] [-L label] [-U uuid] 设备文件名
   -l： 列出这个设备的label name
   -u： 列出这个设备的UUID
   -L： 设置设备的Label name
   -U： 设置设备的UUID

   （3）tunefs修改ext4的Label name ，UUID
   tunefs [-l] [-L Label] [-U uuid]
   -l： 类似dumpe2fs -h的功能，将superblock的数据读出；
   -L： 修改Label name
   -U： 修改UUID


八、设置启动挂载：
   (1)启动挂载/etc/fstab和/etc/mtab：
   要在系统启动时自动挂载，那就在/etc/fstab里面设置；具体要求：
   .根目录/是必须挂载的，而且一定要先于其他挂载点被挂载进来；
   .其他挂载点必须是已挂载的目录，可任意指定，但一定要遵守必须的系统目录架构原则；
   .所有挂载点在同一时间之内，只能挂载一次；
   .所有硬盘分区在同一时间之内，只能挂载一次；
   .如果进行卸载，你必须先将工作目录移到挂载点之外；
   文件内容：
   [设备/UUID等] [挂载点] [文件系统类型] [文件系统参数]  [dump] [fsck]
        1：磁盘设备文件名/UUID/LABEL name:
 	  .文件系统或磁盘的设备文件名，如/dev/dsa*
	  .文件系统的UUID名称，
	  .文件系统的LABEL名称

        2：挂载点：目录
	3：磁盘分区的文件按系统类型
	4.文件系统参数：
	async/sync 磁盘是否以异步方式运行，async（异步）性能较佳，磁盘寿命长。
	auto/noauto：当执行mount -a时，此文件系统是否会被主动测试挂载，默认为
	             auto；

         rw/ro：让该分区以可读取或只读的状态挂在上来。
	 exec/noexec：限制此文件系统内是否可以进行【执行】的工作。如果是纯粹用
	              来存储数据的目录，那么可以设置为noexec会比较安全。但是
		      当一些重要的目录被设置了noexec会出现很多问题，因此，这个
		      最多仅仅设置为用户个人自定义的一般数据文件。


          user/nouser：是否允许用户使用mount命令来挂载。一般而言，我们不希望一
	               般身份的用户使用mount，所以要设置nouser。


          suid/nosuid：该文件是否允许SUID的存在。如果不是执行文件的放置目录，
	               可以使用nosuid来取消这个功能。


           defaults：同时具有rw、suid、dev 、exec 、auto、nouser、async等参数。
	   
	   5.能否被dump备份命令使用：
	   dump是一个用来做为备份的命令，不过现在有太多的备份方案，所以这个项目
	   可以不要理会，直接输入0即可。
	   
	   6.是否以fsck检验扇区：
	   早期启动的流程中，会有一段时间去校验本机的文件系统，看看文件是否完整
	   （clean）。不过这个阶段主要通过fsck来完成，我们现在用的xfs文件系统
	   就没法适用，因为xfs会自己进行检验，不需要这个额外的操作，直接填0；

important：
	   /etc/fstab是启动时的配置文件，实际文件系统的挂载是记录到/etc/mtab
	   与/proc/mounts这两个文件中的。
	   每次我们修改文件系统的挂载时，也会同是修改这两个文件。但是，万一发生
	   /etc/fstab输入数据错误，导致无法顺利启动成功，而进入单人维护模式，
	   那时候/通常是只读的状态，当然你也就无法修改/etc/fstab和/etc/mtab;
	   所以要对/重挂载：
	   mount -n -o remount,rw /

           ps：我第一次写入/etc/fstab文件时，也出错了。但是很辛运，我的单人维
	       护模式是可读写的（rw），所以不用重挂载。而且，写完不要那么快的
	       去重启，可以先试试mount -a测试是否可以挂载。


九、特殊设备loop挂载：
    （1）挂载CD/DVD镜像文件（iso）：
    这些镜像文件不是一定要刻录成为光盘才能够使用该文件里面的数据。可以通过loop
    设备来挂载。
    mount -o loop iso文件 挂载点
    例如：mount -o loop a-DVD.iso /data/image_dvd
    (2)建立大文件（类似镜像文件）以制作loop设备文件：
    既然能够挂载iso文件，那么我们也可以制作一个大文件，然后将这个文件格式化后挂载？
    这可以用来解决分区不合理的问题：当你只划分出一个/目录，假设你没有多余容量来
    进行额外的分区，偏偏/分区的容量还很大。此时只要制作一个大文件并挂载。
      1.建立大型文件：
      dd可以用来建立空文件：详细的自己去查资料；
      example：dd if=/dev/zero of=/srv/loopdev bs=1M count=512
      if: input file ,输入文件(/dev/zero是会一直输出0的设备);
      of：output file,输出文件，将if的数据写入到of里面；
      bs： block size，每个block的大小；
      count：有几个ｂｓ的意思；



　　　　２．大型文件的格式化：
　　　　默认xfs是不能格式化文件的，所以格式化文件得要加入特别的参数；
       mkfs.xfs -f 文件名

       3.挂载：
       利用mount 的特殊参数-o loop来处理：
       mount -o loop UUID="" /mnt


十、 内存交换分区（swap）的创建：
    swap一般用于的时刻通常是物理内存不足的时候。内存的不足时，为了让后续的程序
    可以顺利进行，需要将暂时不适用的程序与数据挪到内存交换分区中，此时内存就会
    空出来给需要执行的程序加载。由于内存交换分区是用磁盘来暂时放置内存的信息，
    所以用到它时，你的主机磁盘灯就会开始闪个不停。
    现在的电脑大都有4GB以上的内存，所以个人使用的电脑不用swap分区；但是，服务器
    就不一样了，网络上来的数据可以很多，因此最好预留一些内存交换分区来缓冲一下系
    统的内存使用量，至少达到【备而不用】的地步。同时，有一部分程序就是需要有swap
    来暂时存储数据，例如电源管理。
    
    1.使用物理分区创建内存交换分区：
      .分区：使用f/gdisk在磁盘中划分一个分区给系统做内存交换分区；
      .格式化：利用mkswap来格式化该分区为内存交换分区格式；
      .使用最后将该swap设备启动，方法名为[swapon 设备文件名]；
      .观察：通过free与swapon -s这个命令来查看内存使用量
    
    2.使用文件创建内存交换文件：
      dd:
      dd if=/dev/zero of=/tmp/swap bs=1M count=128
      mkswap /tmp/swap
      swapon /tmp/swap
      swapon -s
      swapoff /tmp/swap
      swapon -s



十一、文件系统的特殊观察与操作：
    一个区块只能放置一个文件的数据，因此，太多的小文件将会浪费非常多的磁盘
    容量。但是，整个文件系统的superblock、inode对照表以及其他的中介数据等
    其实都会浪费磁盘容量。
    ls -l 第一行都会出现total的字样。后面是该目录下的所有数据所消耗的实际区
    块数量*区块大小的值。


十二、利用GNU的parted进行分区操作
    我们已经有fdisk和gdisk了，但是这两个各自支持MBR和GPT。不过有一个两种都
    支持的方法：parted
    parted [设备] [命令[参数]]（用man parted看）
    新增分区：mkpart [part-type(primary/extended/logical)] [fs-type] start end
    显示分区：print
    删除分区：rm [partition]
    parted最好用在需要一口气完成分区的建立，而不需要一条一条地建立。
    可以使用脚本来实现。