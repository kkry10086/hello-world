1.磁盘与目录的容量：
   df：列出文件系统的整体磁盘使用量；
   du：查看文件系统的磁盘使用量;

   df：主要读取的数据几乎都是针对一整个文件系统，因此读取的范围主要都是在
       超级区块内的信息，所以这个命令显示结果的速度非常快。

   du：du会直接到文件系统内区查找所有的文件数据，所以du所用时间会较长。

2.硬链接和符号（软）链接：ln
   链接文件有两种：一种是类似windows的快捷方式，可以让你快速连接到目标文件；
   另一种是通过文件系统的inode链接来产生新文件名，而不是产生新文件，这种称为
   硬链接。
   
   .硬链接：
     文件名只与目录有关，但是文件内容则与indoe有关；因此，多个文件名可以对应
     到多个inode；硬链接只是某个目录下新增一条文件名连接到某inode号码的关联
     记录而已。(如果不理解，那么就去看file_system.md)
     限制：不能跨文件系统；不能链接目录；
	 example：假设我在/kkk建立/etc的硬链接,那么/etc的文件都要链接到/kkk，
	          那么/etc有改变，那么/kkk也要进行再一次链接。这将造成相当大
		  的环境复杂度。


   .符号链接（symbolic link）：
     符号链接就是建立一个独立的文件，而这个文件会让数据的读取指向它链接的那个
     文件的文件名。与硬链接不同，符号链接的文件与被链接文件的inode不同。
     链接文件的重要内容就是他会写上目标文件的文件名。
   ln [-sf] source-file destination-file
   -s：不加参数就是硬链接，加了-s就是符号链接；
   -f:如果文件目标存在，就主动将目标文件删掉后再创建。（谨慎使用，最好不用）


三、磁盘的分区、格式化、校验与挂载：
   如果我们想要在系统里新增一块磁盘时，需要的操作：
   .对磁盘进行划分，以建立可用的硬盘分区；
   .对该硬盘分区进行格式化（format），以建立系统可用的文件系统；
   .若想要仔细一点，则可对刚刚建立好的文件系统进行校验；
   .在Linux系统上，需要建立挂载点，并将它挂载上来。


   1.观察磁盘分区状态：
  （1） lsblk【list block device】列出系统上的所有磁盘列表。
   输出的信息：
   NAME:就是设备的文件名，会省略/dev等前导目录
   [MAJ:MIN]：其实内核识别的设备都是通过这两个代码来实现的，分别是主要与次要
               设备代码；
   RM:是否为可卸载设备（removable device），如光盘，usb等；
   SIZE:容量；
   RO:是否为只读设备；
   TYPE:是磁盘（disk）、分区（partition）还是只读存储器（rom）等；
   MOUNTPOINT:挂载点。

   （2）blkid列出设备的UUID等参数：（root）
   lsblk -f 可以列出；
   UUID是全局唯一标识符（universally unique identifier），Linux会将系统内的
   所有的设备都给予一个独一无二的标识符，这个标识符可以拿来作为挂载或是使用这个
   设备或者文件系统。

    （3）parted列出磁盘的分区表类型与分区信息：
    parted device-name print

四、磁盘分区：gdisk和fdisk：
   用GPT举例：
   gdisk device-name对device进行分区；
   device-name后面不要加数字，磁盘分区是对整个磁盘分区，而不是某个分区。
   （1）用gdisk新增分区：自己看用man
   （2）partprobe更新Linux内核的分区表信息
   partprobe [-s] 不加s屏幕就不会出现信息。
   万分注意：不要去处理一个正在使用的分区（挂载）。假设，你已经使用了/dev/sda1.
   如果你要删除它，那么就必须先将/dev/sda1卸载，否则直接删除该分区的话，虽然
   磁盘还是会写入正确的分区信息，但是内核会无法更新分区表的信息。
   
五、磁盘格式化：
   mkfs（make filesystem）这个命令会调用正确的文件系统格式化工具软件。
   格式化就是创建文件系统
   创建XFS文件系统：mkfs.xfs
   mkfs.xfs　[-b bsize] [-d parms] [-i parms] [-l parms] [-L label] \
   [-f] [-r parms] 设备名称

   -b：后面接的是区块容量，可由512到64K，但是linux最多支持4K
   -d：后面接的是重要的data section的相关参数
   -i：与inode有较相关的设置
   -f：假设分区已有文件系统，则需要用-f来强制格式化
   -L：后面接文件系统的表头名称Label name
   -r：制定realtime section的相关设置值，常见的有：extsize=num
       设置extent的数值。

   Xfs文件系统for RAID性能优化（optional）：
   RAID（磁盘阵列）就是多块的磁盘组成一块大磁盘的意思，利用同步写入到这些磁盘
   的技术，不但可以加快读写速度，还可以让某一块磁盘坏掉时，整个文件系统还是可
   以持续运行，这就是容错。
   基本上RAID就是通过将文件先细分成数个小型的分区区块（stripe）之后,然后将
   众多的stripes分别放在磁盘阵列里面的所有磁盘，所以一个文件是被同时写入到
   多个磁盘中的，当然性能会好一点。为了文件的安全性，所以在这些磁盘中，会保
   留数个（与磁盘阵列的规划有关）校验磁盘（parity disk），以及可能会保留一
   个以上的备用磁盘（spare disk），这些区块基本上会占用掉磁盘阵列的总容量，
   不过对于数据的安全比较有保障。
   最好等到学完了14章再来看。


   
   mkfxs.ext4 [-b size] [-L label] 设备名称
   -b：设置区块大小
   -L：后面接设个设备的标头名称


五、文件系统校验：
  通常只有身为root且文件系统有问题的时候才使用这个命令，否则在正常情况下使用
  此命令，可能会造成对系统的危害。
   （1）xfs_repair处理XFS文件系统：
   xfs repair [-fnd] 设备文件：
   -f：后面的设备其实是个文件而不是实体设备
   -n：单纯检查并不修改文件系统的任何数据
   -d：通常用在单人维护模式下面，针对根目录（/）进行检查与修复的操作，很危险，
       不要随便使用。

   限制：修复文件系统时，该文件系统是不能被挂载的。只有先卸载了，才能检查。
         但是（/）是不能被卸载的，所以当/有问题时，要进入单人模式，使用-d
	 这个选项来处理。加入-d这个选项后，系统会强制检验该设备，检验完毕后
	 就会自动重新启动。

   （2）fsck.ext4处理ext4文件系统：
   fsck.ext4 [-pf] [-b superblock] 设备名称
   -p：当文件系统在修复时，若有需要回覆y的操作时，自动回覆y来继续进行修复操作；
   -f：强制检查，一般来说，如果fsck没有发现热河unclean的标识，不会主动进入详
       细检查的，如果你想要强制fsck详细检查，就用-f；
       
   -D：针对文件系统下的目录进行最佳化配置；
   -b：后面接超级区块的位置，一般用不到。但是如果超级区块损坏了，通过这个参数
       即可利用文件系统内备份的超级区块来尝试回复，一般来说，超级区块备份在：
       1K区块放在8193,2K区块放在16384,4K区块放在32758


六、文件系统的挂载与卸载：
要求：
    .单一文件系统不应该被重复挂载在不同的挂载点（目录）中；
    .单一目录不应该重复挂载多个文件系统；
    .要作为挂载点的目录，理论上应该都是空目录才行。

    当目录下面有文件，此时挂载了文件系统之后，原目录下的东西就会暂时消失。
    其实是被影藏了。等到卸载了文件系统后，原本的内容就会再次出现。
    （1）mount
