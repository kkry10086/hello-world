11　正则表达式
   11.1含义：
   简单地说，正则表达式就是处理字符串的方法，它以行为单位来进行字符串的处理操作，
   正则表达式通过一些特殊符号的辅助，可以让用户轻易地完成［查找，删除，替换］某
   特定字符串的处理过程．
   正则表达式是一种表示法，只要程序支持这种表示法，那么该程序就可以用来作为正则
   表达式的字符串处理之用．
   对于管理员来说，正则表达式是筛选信息的利器，非常好用．
   正则表达式与bash一样都是Linux中基础中的基础，必须先学好．
   分为基础与扩展两种类型的正则表达式．


   11.2基础正则表达式：
   对字符排序有影响的语系数据就会对正则表达式的结果有影响．
     11.2.1语系对正则表达式的影响:
     每一种语系的字符编码都是不同的,那么此时[A-Z]就会出现很多不同的结果.
     所以我们使用正则表达式的时候,需要特别注意我们当时环境的语系是什么,否则
     就可能会出现与别人不同的选取结果.
     我们下面的语系练习,都是使用LANG=C这个语系来进行的.
     
     [:alnum:]代表英文大小写字符及数字,0-9,a-z,A-Z;
     [:alpha:]代表任何英文大小写字符,a-z,A-Z;
     [:blank:]代表空格键与[tab]键两者;
     [:cnctl:]代表键盘上面控制按键,包括CR,LF,Tab,Del等;
     [:digit:]代表数字,0-9;
     [:graph:]除了空格符(空格键与[tab])以外的其他所有按键;
     [:lower:]代表小写字符,a-z;
     [:upper:]代表大写字符,A-Z;
     [:print:]代表任何可以被打印出来的字符;
     [:punct:]代表标点符号(punctuation symbol),"?!',.#$%等;
     [:space:]任何会产生空格的字符;
     [:xdigit:]代表十六进制的数字类型,包括0-9,a-f,Z-F等;



   11.2.2 grep的一些高级选项:
   grep [-A] [-B] [--color=auto] '查找字符' filename;
   -A:后面可加数字,为after的意思,除了列出该行外,后续的n行也列出来
   -B:后面可加数字,为before的意思,除了列出该行外,前面的n行也列出来;


   11.2.3 基础正则表达式的练习:
   ^符号在[]内是相反的含义,而在[]之外是行首的意思.
   .具有特殊含义,代表任意一个字符,因此使用时,要使用\来进行转义;
   *具有特殊含义,代表重复前一个字符多次,可以是0-无穷次(包含前一个字符在内).
   上面的两个符号在通配符里面就有所不同.


   使用限定范围RE字符范围{}
   前面我们可以使用*是的同一个字符重复0-无穷次,那么,我们如果就是要限定次数呢?
   此时就可以使用{},由于{}在shell中是由特殊意义的,所以要用\来转义.
   example:grep -n '0\{2,5\}' filename/stdout

   11.2.4基础正则表达式字符集合(characters)



   11.2.5sed工具:
   sed [-nefr] [操作]
   -n：使用安静（silent）模式，在一般sed的用法中，所有来自stdin的数据一般都会被
       列出到屏幕上。但如果加上-n,则只有经过sed特殊处理的那一行才会被列出来。
   -e：直接在命令行模式上进行sed的操作编辑。
   -f：直接将sed的操作写在一个文件内，-f filename则可以执行fielname内的sed操作。
   -r：sed的操作使用的是扩展型正则型表达式的语法。
   -i：直接修改读取的文件内容，而不是由屏幕输出。
   
   [操作]的说明:
   [n1[,n2]] function
   n1，n2代表的是行数；
  
   function有下面这些东西：
   a　：新增，ａ的后面可以接字符，这些字符会出现在新的一行。
   c　：替换，ｃ的后面可以接字符，这些字符可以替换n1与n2之间的行。
   d　：删除，后面通常不接任何东西。
   i　：插入，i的后面可以接字符，而这些字符会在新的一行出现。
   p　：打印，亦即将某个选择的数据打印出来。
   s　：替换，可以直接进行替换的工作，通常这个s的操作可以搭配正则表达式。

 a和i可以新增数据，这个可以增加多行，当时每一行的而后面一定要加\
   关于s：用法是sed 'n1,n2s/old/new/g'
   关于d：sed 'n1,n2d'/sed '/正则表达式/d'
   sed可以直接对文件进行修改直接在最后面加上文件名就行
   sed -i '[操作]' 文件名



   11.3 扩展正则表达式

    扩展正则表达式可以通过群组功能|来进行一次查找。由于grep仅支持基础正则表达式。
    不过 grep -E或者egrep可以使用扩展正则表达式。
    
    RE字符
    + ：【一个或一个以上字符】
    ？：【零个或一个字符】
    | ：使用or的方式找出数个字符串
    （）：找出群组字符，将一组字符当成一个整体
    （）+：相当于群组字符当成一个整体，后面加一个+





    11.4 文件的格式化与相关处理：
    主要介绍printf 和awk

    11.4.1格式化打印：printf
    printf '打印格式' 实际内容
    \a   警告声音输出
    \b   退格键（backspace）
    \f   清除屏幕（form feed）
    \n   输出新的一行
    \r   回车键
    \t   水平的【tab】键
    \v   垂直的【tab】键
    \xNN NN为两位数的数字，可以转换数字成为字符
    关于c语言程序内，常见的常量格式 

    %ns   n是数字，s是string，多少个字符
    %ni   n是数字，i是integer，多少个数字
    %N.nf n，N是数字，f代表floating，如果有小数位数，假设我要总长为十位数，
          两个小数的数字，那么就是10.2f
    顺带一提，n/N没有写的话，就代表是不固定长度的。

    printf '%s\t %s\t %s\t %s\t %s\t \n' $(cat fname)
    由于printf不是管道命令，因此要通过$（）就爱你该文件内容先提出来给printf作为
    后续数据才行。
    
     也可以使用ascii的方式显示，例如printf '\x76\n' 输出v

     11.4.2 awk:好用的数据处理工具
      相较于sed常常用于一整行的处理，awk则倾向于一行当中分成数个字段来处理。
     awk '条件类型 ｛操作1｝条件类型 ｛操作2}...' filename
     
     awk主要处理每一行的字段内的数据，而默认的字段的分隔符为"空格键"或"【tab】".
     last -n 5| awk '{printf $1 "\t" $3 "\n"}'
     每一行的每个字段都有变量名称，就是$1,$2,$3等，而$0代表一
     整行的数据。
 
     整个awk的处理流程是：
     1.读入第一行，并将第一行的数据写入到$0,$1,$3等变量里面。
     2.根据"条件类型"限制，判断是否需要进行后面的"操作"。
     3.完成所有操作与条件类型。
     4.若还有后续的【行】的数据，则重复1~3的步骤，知道所有的数据读完。
 
     awk通过自己的内置变量来知道要处理数据的情况：
     NF：每一行{$}的字段总数
     NR：目前awk所处理的是第几行的数据
     FS：目前的分隔字符，默认是空格键


     awk的逻辑运算字符：
     既然需要用到条件，那么就需要运算符号。
     运算符基本与c语言中的相同。
     example： cat /etc/passwd |awk '{FS=":"} $3<10 {print $1 "\t uid:
     " $3 "\n"}'
     {FS=":"}设置了分隔符是行数，$3<10 是设置条件。
     这个条件还是有一个问题：仅在第二行才生效。因为awk的处理模式是先读入变量，
     此时就使用了空格的分隔符，之后才来判断，此时这一行没有空格，所以$1就相当于
     $3。
     所以改进是：
      cat /etc/passwd |awk 'BEGIN {FS=":"} $3<10 {print $1 "\t uid:
     " $3 "\n"}'
     
     除了BEGIN的功能，还有END。
     如果记录里面是数据，我们想要计算总数或是平均值也可以使用awk：
     cat fname |\
     awk 'NR==1 {printf "%10s %10s %10s %10s %10s \n",$1,$2,$3,$4,"total"};
     NR>=2 {total=$2 + $3 + $4;printf "%10s %10d %10d %10d %10.2f \n",$1,$2,
     $3,$4,total}'
   
     1.awk的命令间隔：所有awk的操作，即在｛｝里面的操作，如果需要多个命令辅助时，
     可利用分好【；】来间隔，或直接按【enter】来间隔。即每个操作之间都需要间隔。
     
     2.逻辑运算当中，如果是【等于】，使用两个等号。

     3.格式化输出时，printf的格式设置当中，务必使用"\n"，才能分析。
   
     4.与bash shell的变量不同，在awk当中，变量是可以直接使用的，例如上面的
      total，不需要加上$。
 

     11.4.3文件对比工具：
     什么时候会用到文件的对比？通常是同一个软件包的不同版本之间，比较配置文件与原始 
     文件的差异。
 
     有diff还有cmp两种。
     diff常用于纯文本文件而cmp常用语常用于非纯文本文件。diff建立的分析文件，可以
     用于处理补丁（patch）功能的文件。

     。diff
     用在比对两个文件的差异，git用的也是这种方式。并且是以行为单位来对比，因此，diff
     通常是用在同一个文件（或软件）的新旧版本差异上。
 
     diff [-bBi] from-file to-file
     -b：忽略一行当中，仅有多个空白的差异（用在代码上面）
     -B：忽略空白行的差异
     -i：忽略大小写的不同

     结果以sed中的function的表现形式表现

     。cmp：没有diff智能，很笨
     主要是利用字节单位去对比，当然也可以是二进制文件。
     cmp [-l] file1 file2
     -l：将所有的不同点都列出来。默认只认出第一个不同点。


     。patch：
     patch这个命令与diff有着密不可分的关系。diff可以用来辨别两个版本之间的差异。
     如果要升级？就是将旧的文件升级为新的文件时，应该怎么做。
     本质上是比较双方的差别，并将差异文件制作称为补丁文件，再由补丁文件更新旧文件
     就行。

     example：diff -Naur oldfile newfile >file.patch
     cat file.patch可以看到两个文件要进行修改的数据的界定范围，
     还有两个文件对于这一范围的数据的不同。

     一般来说diff制作的数据用.patch作为扩展名。至于内容就如同上面介绍的样子。
     一行为单位。

     patch -pN <patch_file
     patch -R　-pN < patch_file
     -p：后面可以接【取消几层目录】的意思。
     -R：代表还原，将新的文件还原成原来的旧文件。
     patch会自动找到相应的旧文件，并升级为新文件。
     详细的patch的教学在后面。diff也可以用来对比目录。
    

     11.4.4文件打印设置：pr
     pr的参数太多，要自己去学。
     pr /etc/manpath.config





     
    


     
   
   
   

     
