			16 进程管理与SELinux初探

16.1什么是进程(process)
  在linux系统当中:[触发任何一个事件时,系统都会将他定义成为一个进程,并且给予这个进程一个ID,称为PID,同时依据启发这个进程的用户与相关属性关系,给予这个PID一组有效的权限设定.]

  16.1.1 进程与程序(process&program)
  进程的产生:执行一个程序或指令,然后就可以触发一个事件从取得一个PID.系统只认识二进制文件(binary file),binary file就是程序(program).
  进程一般是放置在实体磁盘中,然后透过用户的执行来触发.出发后会加载到内存中成为一个个体,那就是进程.为了操作系统可以管理这个进程,因此进程有给予执行者的权限/属性等参数,并包括程序所需要脚本与数据或文件数据等,最后再给予一个PID.系统就是透过这个PID来判断该process是否具有权限进行工作.当执行指令时,这个进程衍生出来的其他进程在一般状态下,也会沿用这个进程的相关权限.

  总结:
  程序(program):通常为binary program,放置在储存媒体中,为实体文件的形态存在.
  进程(process):程序被触发后,执行者的权限与属性,程序的程序代码与所需数据等都会被加载内存中,操作系统并给予这个内存内的单位一个标识符(PID),可以说,进程就是一个正在运行中的程序.

   1.子进程与父进程:
   我们使用bash这个shell程序时,使用touch等指令时,这个指令会产生一个新的进程,这个新的进程就是子进程,而产生这个子进程的bash进程就是父进程.

   2.fork and exec: 进程呼叫的流程
   在linux的进程呼叫通常成为fork-and-exec的流程.进程都会皆由父进程以复制(fork)的方式产生一个一模一样的子进程(此时更应该称为暂存进程),然后被复制出来的子进程再以exec的方式来执行实际要进行的程序,最终就成为一个子进程的存在.因此父进程与子进程的差别就在与PID和PPID,执行的程序,两者的环境基本相同.

   3.系统与网络服务:常驻在内存的进程
   我们知道系统每分钟都会去扫描/etc/crontab以及相关的配置文件,来进行工作排程.那么这个工作排程是谁负责?是crond这个程序所管理的,我们将它启动在背景当中一直持续不断的运作,这就是常驻在内存中的进程.
   
   常驻在内存当中的进程通常是负责一些系统所提供的功能以服务用户各项任务,因此这些常驻程序就会被我们称为:服务(daemon).系统的服务非常多,不过主要大致分成系统本身所需要的服务,还有一些则是负责网络联机的服务,而网络服务比较有趣的地方,在于这些程序被执行后,它们会启动一个可以负责网络监听的端口(port),以提供外部客户端(client)的联机要求.
   

  16.1.2 Linux的多人多任务环境

    1.多人环境:
      linux最棒的地方就在于它的多人多任务环境.在Linux系统上面具有多种不同的账号,每 种账号都有其特殊的权限,只有一个人具有至高无上的权利,那就是root(系统管理员).除了root之外,其他人都必须要受一些限制,而每个人进入linux的环境设定都可以随着每个人的喜好来设定.
    2.多任务行为:
      CPU切换进程的工作,与这些工作进入到CPU运作的排程会影响到系统的整体效能.目前Linux使用的多任务切换行为是非常棒的一个机制,几乎可以将PC的性能整个压榨出来.由于效能非常好,因此当多人同时登陆系统时,会感觉整部主机好像是为了你存在一般.
 
    3.多重登入环境的七个基本终端窗口:
      在Linux当中,默认提供了六个文字界面登入窗口,以及一个图形界面,可以使用[alt]+[FN]来切换不同的终端机界面.细节部分19章学习.

    4.特殊的进程管理行为:
      Linux几乎可以说绝对不会当机(kkry我就有过一次,当然电脑差是一个重要原因),因为它可以在任何时候,将某个被困住的进程杀掉,然后在重新执行该进程而不用重新启动.如果我们在某一个终端界面挂了,就可以切换其他的界面.然后使用pa -aux,找到错误进程,然后kill.

    5.bash环境下的工作管理(job control):
      其实当你使用apt update 和apt upgrade这时有时会要很长的时间来更新,会给你一个终端只能执行一个任务.但是你可以在命令的后面加上&符号,将其放在背景完成,这样就可以继续使用bash来执行工作.

    6.多人多任务的系统资源分配问题考虑:
      多人多任务的确有很多的好处,但其实也有管理上的困扰,因为使用者越来越多,将导致你管理上的困扰.另外,当使用者达到一定数量后,你的机器便需要省级,因为CPU的运算与RAM的大小可能就会不够使用.


16.2 工作管理(job control)
  工作管理就是在用在bash环境下的，也就是说：「当我们登入系统取得bash shell之后，在单一终端机接口下同时进行多个工作的行为管理」。

  16.2.1什么是工作管理
  进行工作管理的行为中，其实每个工作都是目前bash的子进程，亦即彼此之间是有相关性的。我们无法以job control的方式由tty1的环境去挂你了tty2的bash。
  由于假设我们只有一个终端接口，因此可以出现提示字符让你操作的环境就称为前景（foreground），至于其他工作就可以让你放入北京（background）去暂停或运行。放入背景的工作想要运行时，其必须不能够与使用者互动。放入背景的工作是不可以使用「ctrl」+c来终止的。
  总结：这些工作所触发的进程必须来自于shell的子进程；你可以控制与下达指令的这个环境成为前景（前台）的工作；背景：可以自行运作的个哦你做，你无法使用「ctrl」+c终止它，可使用bg/fg呼叫该工作；背景中「执行」的进程不能等待terminal/shell的输入。


  16.2.2job conrtol 的管理
    任务分为前景（前台）与背景（后台），然后，背景里面的工作状态又可以分为「暂停(stop)」与「运作中(running)」。实际进行job控制的指令：

    1.直接将指令丢到背景中「执行」&
    我们在只有一个bash的环境下，如果想要同时进行多个工作，那么可以将某些工作直接丢到背景环境中，让我们可以继续操作前景的工作。将工作丢到背景的最简单的方法：利用「&」。
    假设我们要将/etc备份到/tmp/etc.tar.gz：
    tar -czf /tmp/etc.tar.xz /etc &
    但是当这条指令变成 tar -czvf /tmp/etc.tar.xz /etc & 时，此时其会将该任务的情况表现在前台，这就会影响前台的操作，所以一旦加上-v等类似可以想前台报告情况的选项时，可以使用数据流重定向，将数据转发到其他的文件：/dev/null都可以。
    例如：tar -czvf /tmp/etc.tar.xz /etc > /dev/null 2>& 1 &

    2.将「目前（前台）」的工作丢到背景（后台）中「暂停」：「ctrl」+z
    假设我们在使用一个vim的程序，却发现我们要打开一个文件，但是不知道在哪里，需要在bash的环境下进行搜寻，此时不一定要结束vim，我们可以暂时将vim放到后台中等待就行了。
    在vim的一般模式下，按下「ctrl」+z，屏幕就会出现「1」，表示这是第一个工作，而那个+代表最近一个被丢进背景的工作，且目前在背景下预设会被去用的吧和工作（与fg这个指令有关）。而那和Stopped则代表目前这个工作的状态。在预设的情况下，使用「ctrl」+z丢到背景当中的工作都是「暂停」的状态。

    3.观察目前的背景工作状态：jobs
    jobs [-lrs]
    -l：除了列出job number与指令串之外，同时列出PID的号码；
    -r：仅列出正在背景run的工作；
    -s：仅列出正在背景当中暂停(stop)的工作。
    在列出的结果中还有+/-号，+号代表预设的取用工作。「目前我有两个工作在背景当中，两个工作都是暂停的，而如果我仅输入fg时，就会取用有+号的任务到前景来使用。」
    
    4.将背景工作拿到前景来处理：fg
    之前都是讲如何将工作放到背景去执行，现在来讲将背景的工作拿到前景来处理。
    fg %jobnumber
    %jobnumber:jobnumber为工作号码。注意：%可以不加。
    jobnumber可以使用jobs查看到。
    fg +/- 取出有+/-的任务。
    
    5.让工作在背景下的状态变成运作中：bg
    我们如何让一个在背景中暂停的工作变成运行中「running」,使用bg；
    bg %jobnumber
    使用方式与fg类似。
    
    6.管理背景当中的工作：kill
      那么将工作移除或是让其重新启动，这个时候就得需要给予该工作一个讯息(signal)，让他知道该怎么作才好。此时，kill这个指令就派上了用场。
      kill -signal 「%jbnumber」/「PID」
      kill -l
      -l：列出目前kill能够使用的讯号有哪些。
      signal：代表给予后面接的那个工作什么样的指示。用man 7 signal可知。
        -1：重新读取一次参数的配置文件（类似reload）
	-2：代表与由键盘输入「ctrl」+c 同样的动作
	-9：代表强制删除一个工作
	-15：以正常的进程的方式终止一项工作。
	-9通常是用来「强制删除一个不正常的工作」。-15是以正常的步骤结束一项工作。两者并不相同。

  
  16.2.3 脱机管理问题
  之前讲的情况都是在主机情况下，但是，如果我们以远程联机的方式链接到Linux主机，并且将工作以&的方式放到背景中，假设此时在工作为结束时，你脱机了，该工作还会进行吗？答案是「否」。这个工作会中断掉。
   那怎么办，我们的工作需要一大段时间，又不能放置在背景（可能会忘掉）。此时我们可以考虑使用at，at与系统有关，但是与终端无关。如果不使用at，那么还有nohup这个指令，这个nohup可以让你在脱机或注销系统后，还能够让工作继续进行。

    nohup [指令与参数]
    nohup [指令与参数] &
    nohup并不支持bash内建的指令，因此你的指令要是外部指令才行。
    nohup也与终端机无关，因此这个讯息的输出会被导向「~/nohup.out」，所以当你输入nohup会告知你信息会重定向到~/nohup.out。


16.3进程管理
  本章一开始就提到所谓进程的概念，进程的触发、子进程与父进程的相关性等，此外，还有那个「进程的相依性」以及所谓的「僵尸进程」等等需要说明。


  16.3.1进程的观察
    1.ps:将某个时间点的过程运作情况攫取下来
      ps aux：观察系统所有的进程数据
      ps -lA：观察所有系统的数据
      ps axjf：连同部分进程树状态
      选项与参数
      -A：所有的process均显示出来，与-e相同；
      -a：不与terminal有关的所有process；
      -u：有效使用者(effictive user)相关的process；
      x ：通常与a这个参数一起使用，显示较完整的信息；
      输出格式规划
      l ：较长、详细的将该PID信息列出；
      j ：工作的格式(jobs format)；
      -f：做一个更为完整的输出；

      最重要的两个ps：
      a.ps -l：仅观察自己的bash相关进程
      F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
      0 S  1000  154410  154384  0  80   0 -  3823 do_wai pts/0    00:00:00 bash
      0 R  1000  159513  154410  0  80   0 -  3944 -      pts/0    00:00:00 ps

      上面就是 ps -l 的结果，
      F：代表这个进程旗标(process flags)，说明这个进程的总结权限。
      若为4表示次进程的权限为root;
      若为1则表示此子进程仅进行复制(fork)而没有实际执行(exec)

      S：代表这个进程的状态(STAT),主要状态有：
        a.R(Running)：该程序正在运行中；
	b.S(Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)；
	c.D：不可被唤醒的睡眠状态，通常这支程序可能在等待I/O的情况；
	d.T：停止状态(stop)，可能是在工作控制（背景暂停）或除错(traced)状态；
	e.Z(Zombie)：僵尸状态，进程已经终止但却无法移除至内存外。

      UID,PID,PPID：代表此进程该UID所拥有的进程的PID号码，与其父进程的PID号码。

      C：代表CPU的使用率，单位为百分比。
 
      PRI/NI：Priority/Nice的缩写。代表此进程被CPU所执行的优先级，数值越小代表该进程越快被CPU执行。
      
      ADDR/SZ/WCHAN：都与内存有关，ADDR是kernel function，指出该进程在内存的那个部分，如果是个running的进程一般都会显示「-」；SZ代表此进程用掉多少内存；WCHAN表示目前进程是否运作中，同样的，若为-表示正在运作中。
      
      TTY：登入者的终端位置，若为远程登陆则使用动态CPU终端接口(pts/n)。
      
      TIME：使用掉的CPU时间，注意，是此进程实际花费CPU运作的时间，而不是系统时间。
      
      CMD：就是command的缩写，造成此进程的触发程序的指令。

      b.ps aux :
      
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root           1  0.5  0.1 167000 12312 ?        Ss   06:38   0:02 /sbin/init splash
root           2  0.0  0.0      0     0 ?        S    06:38   0:00 [kthreadd]
root           3  0.0  0.0      0     0 ?        I<   06:38   0:00 [rcu_gp]
      可以看到 ps -l 与ps aux的结果不同，在ps aux中，各字段的含义：
      USER：该process属于哪个使用者的账号；
      PID：该process的进程标识符；
      %CPU：该process使用调的CPU资源百分比；
      %MEM：该process所占用的物理内存百分比；
      VSZ：该process使用掉的虚拟内存量(Kbytes)；
      RSS：该process占用的固定的内存量(Kbytes)；
      TTY：该process是在那个终端机上面运作，若与终端机无关，则显示?，另外，tty1-tty6是本机上面的登入者进程，若为pts/0等等的，则表示为由网络连接进主机的进程。
      STAT：该进程目前的状态，状态显示与 ps -l 的S旗标相同(R/S/D/T/Z)；
      START：该process被触发启动的时间；
      TIME：该process实际使用的CPU运作的时间；
      COMMAND：该进程的实际指令。

      

      c.僵尸进程(zombie)：
        原因：因为该进程应该执行完毕，或者是因故障应该要终止了，但是该进程的父进程却无法完整的将该进程结束，而造成那个进程一直存在内存当中。如果某个进程的CMD后面还接上<defunct>时，就代表该进程是僵尸进程。
	当系统不稳定时就容易造成所谓的僵尸进程，可能是因为程序写的不好，或者是使用者的操作习惯不良等等所造成的。如果你发现系统中很多僵尸进程时，要记得找出父进程，然后好好的做个追踪，好好的进行主机的环境优化。不要直接的kill，否则以后还是会产生的。
	事实上，通常僵尸进程都已经无法管控，而直接是交给systemd这支程序来负责，偏偏systemd是系统第一支程序，是所有程序的父程序。我们无法杀掉该程序的。所以，如果产生了僵尸进程，而系统过一阵子还没有办法透过核心非经常性的特殊处理来将该进程删除时，就只好reboot来将该进程抹去。



    2.top 动态观察进程的变化
    相对于ps是擷取一个时间点的进程状态，top则可以持续侦测进程运作的状态。
    
    top [-d 数字] |top [-bnp]
    选项与参数：
    -d：后面可以接秒数，就是整个进程画面更新的描述，预设是5秒。
    -b：以批次的方式执行top，还有更多的参数可以使用。通常会搭配数据流重导向来将批次的结果输出成为文件。
    -n：与-b搭配，意义是，需要进行几次top的输出结果。
    -p：制定某些个PID来进行观察检测。
    
    在top执行过程中，可以使用的按键指令：
    ?：显示在top当中可以键入的按键指令
    P：以CPU的使用资源排序显示
    M：以Memery的使用资源排序显示
    N：以PID来排序
    T：有该Process是使用的CPU时间积累排序
    k：给予某个PID一个讯号
    r：给予某个PID重新制定一个nice值
    q：离开top软件的按键。
	
	
进程号 USER      PR  NI    VIRT    RES    SHR    %CPU  %MEM     TIME+ COMMAND
6453   zcj       20   0 5769228 334072 143980 S  10.4   4.2   9:17.40 gnome-s+ 
16636  zcj       20   0 3256212 229688 131712 S   3.6   2.9   2:34.64 clement+ 

     PID：Process的ID；
     USER：该process所属的使用者；
     PR：Priority的简写，进程的优先执行顺序，越小越早被执行；
     NI：Nice的简写，与Priority有关，越小越早被执行；
     %CPU：CPU的使用率。
     %MEM：内存的使用率。
     TIME+：CPu使用时间的累加。



    3.pstree ：
    pstree [-A|U] [-up]

    选项与参数：
    -A：各进程之间的连接以ASCII字符来连接；
    -U：各进程之间的连接以万国码的字符来连接，在某些终端接口下可能有错误；
    -p：并同时列出每个process的PID；
    -u：并同时列出每个process的所属账号名称。
    
    所有的进程都是依附在systemd这只程序底下的。其PID是1，因为这支进程是由linux的核心主动呼叫的第一支程序，所以PID就是1号。所以systemd发生僵尸进程时，需要reboot。

  16.3.2进程的管理
  进程之间是可以互相控制的。你可以关闭，重新启动服务器软件，服务器软件本身是个进程，所以就是相应的控制进程。我们是通过给予进程一个信号(signal)来告知进程我们想要它干什么。
  
  使用kill -l或man 7 signal都可以查询到。
  主要的讯号代号与名称对应内容：
  代号   名称             内容
  1    SIGHUP        启动被终止的进程，可让PID重新读取自己的配置文件，类似
                     重新启动
  2    SIGINT        相当于用键盘输入【ctrl】+c来中断一个进程的进行
  9    SIGKILL       代表强制中断一个进程的进行，如果该进程进行到一半，那么
                     尚未完成的部分可能会有半产品产生。
  15   SIGTERM       以正常的结束进程来来终止进程。由于是正常的终止，所以后
                     续的动作会完成。不过，如果该进程已经发生问题，就是无法
		     使用正常的方法终止时，这个signal就没用了。
  19   SIGSTOP       相当于用键盘输入【ctrl】+z来暂停一个进程的机型。


    1.kill -signal PID
  kill可以帮我们将这个signnal传送给某个工作(%jobnumber)或者某个PID。kill后面直接加数字与加上%jobnumber是不同的。%jobnumbber是指工作控制中有n号工作，而直接加数字指的是PID。

    2.killall -signal 指令名称
  由于kill后面必须加上PID或是%jobnumber，所以kill都会配合ps，pstree等指令。因为我们能必须要找到相应的进程的ID。。但是，可以通过指令的名称来给予信号。
  killall [-iIe] [command name]
  选项与参数：
  -i：interactive的意思，交互式的，若需要删除时，会出现提示字符给用户；
  -e：exact的意思，表示【后面接的command name要一致】，但整个完整的指令不能超过15个字符；
  -I：指令名称忽略大小写。


  16.3.3 关于进程的执行顺序
  Linux是多人多任务的环境，由top的输出结果可以发现你，系统同时间有非常多的进程在运行中,只是绝大部分进程都在休眠中。如果所有程序都被唤醒，系统应该先执行哪个程序。此时就要考虑进程的优先执行序(Priiority)与CPU排程。
  CPU排程指的是每支进程被CPU运作的演算规则，而例行性工作排程则是将某支程序安排在某个时间再交由系统执行。CPU排程与操作系统较具有相关性。


    1.Priority与Nice值
    我们知道CPU一秒钟可以执行多达数G的微指令次数，透过核心的CPU排程可以让各进程被CPU所切换运作，因此每个进程在一秒钟内或多或少都会被CPU执行部分脚本。如果进程都是集中在一个队列中等待CPU的运作，，而不具有优先级之分，或导致一些需要紧急完成的任务必须等待很长的时间才能运行，一些需要I/O等其他资源的进程占用的时间又太多。
    Linux给予进程一个所谓的【进程执行序(priority,PRI)】，这个PRI值越低代表越优先执行的意思。不过这个PRI值是由核心动态调整的，用户无法直接调整PRI。
    PRI(new)=PRI(old)+NI
    Nice可以影响PRI，但是最终的PRI仍是要经过系统分析才会决定。Nice可以是负值，nice为负值时，那么该进程就会降低PRI值，亦即会变得较优先被处理。

    nice值可以调整的范围为-20~19；
    root可随意调整自己或他人进程的nice值，范围也是-20~19；
    一般使用者仅可调整自己进程的nice值，且范围仅为0~19（避免一般用户抢占系统资源）；
    一般使用者仅可将nice值越调越高。
    
    如何给予进程nice值：
    a.一开始执行程序就立即给予一个特定的nice值：用nice指令；
    b.调整某个已经存在的PID的nnice值：用renice指令。

    a.nice：新执行的指令即给予新的nice值
    nice [-n 数字] command
    -n：后面接一个数值，数值的范围-20~19。

    b.renice：已经存在进程的nice重新调整
    renice [number] PID


  16.3.4系统资源的观察
  除了系统的进程之外，我们还必须就系统的一些资源进行检查。top可以。

    1.free：观察内存使用情况
    free [-b|k|m|g|h] [-t] [-s N -c N]
    选项与参数：
    -b：直接输入free时，显示的单位时Kbytes，当然也可以使用其他单位，此时就使用其他字母
    -t：在输出的最终结果，显示物理内存与swap的总量
    -s：可以让系统每几秒钟输出一次，不间断的一直输出的意思。对于系统观察很有效。
    -c：：与-s同时处理，让free列出几次的意思。

     free：
     total    used    free    shared    buff/cachhe    available
     total是总量，used是已被使用的量，free则是剩余可用的量，后面的buff/shared/cached则是在已被使用的量当中，用来作为缓冲及快取的量，这些用量在系统比较忙碌的时候，可以被释放而继续利用，因此后面就有一个available（可用的）数值。
     cache是块取的意思，当我们读取一些文件时，还会将保存在内存当中，但是，不会在我们关闭文件时将这些内存写入到硬件，或是将这些数据从内存中删掉。快取是为了等待下次读取时更快的取出。
     Swap最不要被使用到，一旦超过20%，最好考虑购买更大容量的内存条。


     2.uname：查询系统与核心相关信息
     uname [-asrmpi]
     选项与参数：
     -a：所有系统相关的信息，包括底下的数据都会被列出来
     -s：系统核心名称
     -r：核心的版本
     -m：本系统的硬件名称
     -p：CPU的类型，与-m类似，只是显示的是CPU的类型
     -i：硬件的平台

      3.uptime：观察系统启动时间与工作负载
      这个指令就是显示出目前系统已经开机多久的时间，以及1,5,15分钟的平均负载。
      
      4.netstat：追踪网络或插槽文件(socket file)：
      netstat比较常用在网络的监控方面，不过，在进程管理方面也是需要了解的。
      netstat的输出分为两大部分，分别是网络与系统自己的进程相关性。
      netstat -[atunlp]
      选项与参数：
      -a：将目前系统上所有的联机、监视、Socket数据都列出来；
      -t：列出tcp网络封包的数据；
      -u：列出udp网络封包的数据；
      -n：不以进程的服务名称，以port number来显示；
      -l：列出目前正在网路监听的服务；
      -p：列出该网路服务的进程PID；

       可以看到互联网联机情况的部分：
       Proto    Recv-Q    Send-Q    Local Address    Foreign Address    State
       Proto：网络的封包协议，主要分为TCP和UDP封包。
       Recv-Q：非由用户程序链接到此socket的复制的总bytes数；
       Send-Q：非由远程主机传送过来acknowledged的总bytes数；
       LocalAddress：本地端的IP:Port情况；
       ForeignAddress：远程主机的IP:Port情况；
       State：联机状态，主要有建立(ESTABLISED)即监听(LISTEN)；

       本机的socket file输出字段有：
       Proto：一般是UNIX；
       RefCnt：连接到此socket的进程数量；
       Flags：联机的旗标；
       Type：socket存取的类型。主要有确认联机的STREAM与不许确认的DGEAM两种；
       State：若为CONNECTED表示多个进程之间已经联机建立；
       Path：连接到此socket的相关程序的路径，或者有相关数据输出的路径。


       4.dmesg：分析核心产生的讯息
       系统在开机的时候，核心会去侦测系统的硬件，硬件是否会被捉到，就与这个侦测有关。但是这些侦测是会被飞速显示出来，所以我们使用dmesg。
       所有核心侦测的讯息，不管是什么时候的，只要是核心产生的讯息，都会被记录到内存中的某个保护区段。dmesg这个指令就能够将该区段的讯息读出来。因为讯息是在太多了，所以执行时可以加入这个管线指令【| more】来使画面暂停。
       dmesg | more

       5.vmstat：检测系统资源变化
       如果你想要动态地了解一下系统资源的运行，就看可以使用vmstat。vmmstat可以检测【CPU/内存/磁盘I/O状态】等，如果你想要了解一个繁忙的系统到底哪个环节最雷人，可以使用vmstat分析。
       vmstat [-a] [延迟[总计检测次数]]  cpu/内存等信息
       vmstat [-fs]                    内存相关
       vmstat [-S 单位]                设置显示数据单位
       vmstat [-d]                     与磁盘有关
       vmmstat [-p 分区]                与磁盘有关
       选项与参数：
       -a：使用inactive/active替换buffer/cache的内存输出信息；
       -f:开机到目前为止，系统复制(fork)的进程数；
       -s：将一些事件（启动至目前为止）导致的内存变化情况列表说明；
       -S：后面接单位，数据显示的单位；
       -d：列出磁盘的读写总量的统计表；
       -p：后面列出分区，可显示该分区的读写总量的统计表。
       
       利用vmstat甚至可以执行跟踪。可以vmstat 5　这样就可以５秒跟新一次，且无穷跟新。除非你结束或停止它。
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free  inact active   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 227948 221616 265444    0    0   190    28   69  152  1  1 98  0  0
　　　　　
　　　　a.进程字段(procs)的项目分别是：
         r：等待运行中的进程数量
         b：不可被唤醒的进程数量
       
       b.内存字段(memory)项目分别是：
         swpd：虚拟内存被使用的量
	 free：未被使用的量
	 buff：用于缓冲存储器
	 cache：用于高速缓存
	 
       c.内存交换分区(swap)的项目分别为：
         si：由磁盘将进程取出的容量
	 so：由于内存不足而将没用到的进程写入到磁盘的swap的容量
         
       d.磁盘读写(I/O)的项目分别是：
         bi：由磁盘读入的区块数量
	 bo：写入到磁盘中的区块数量
	 
       e.系统(system)的项目分别是：
         in：每秒被中断的进程次数
	 cs：每秒执行的事件切换次数
	 
       f.CPU的项目分别是：
         us：非内核层的CPU使用状态
	 sy：内核层所使用的CPU状态
	 id：闲置的状态
	 wa：等待I/O所耗费的CPU状态
	 st：被虚拟机(virtual machine)所使用的CPU状态（2.6.11以后才支持）




16.4 特殊文件与进程

  16.4.1具有SUID/SGID权限的指令执行状态
  SUID的权限其实与进程的相关性非常的大。SUID是如何被一般用户执行：
  a.SUID权限仅对二进制程序(binary program)有效；
  b.执行者对于该程序需要具有x的可执行权限；
  c.本权限仅在执行该程序的过程中有效(run-time)；
  d.执行者将具有该程序拥有着(owner)的权限。
  
  整个SUID的权限会生效是由于「具有该权限的程序被触发」，而程序被触发会变成进程，所以执行者可以具有程序拥有者的权限就是在该程序变成进程的时候。
  当我们使用了passwd后，会取得一个新的进程与PID，该PID产生时透过SUID来给予该PID特殊的权限设定。


  16.4.2 /proc/* 代表的意义
  之前我们提到的进程都是在内存当中，而内存当中的数据又都是写入到/proc/*这个目录下面的，所以，我们当然可以直接观察/proc这个目录当中的文件。
  自己查看：
  基本上，目前主机上面的各个进程的PID都是以目录的形态存在于proc当中。我们开机所执行的第一支程序systemd的PID就是1，这个PID的所有相关信息都写入/proc/1/*当中。
  /proc/1/里面的数据很多，比较有趣的是两个文件：cmdline和environ；
  cmdline：这个进程被启动的指令串；
  environ：这个进程的环境变量内容。

  cat /proc/1/cmdlinei 的结果：
  /sbin/init^@splash^@
  就是这个指令，选项启动systemd。因为这个文件符号连接到了systemd的文件。
  splash应该就是选项或参数。
  lrwxrwxrwx 1 root root 20  6月 28 02:28 /sbin/init -> /lib/systemd/systemd
  
  这是跟某个特定的PID有关的内容，如果是针对整个Linux系统相关的参数，就直接在/proc目录底下的文件里面。其对应内容是：
  |   档名       |                         文件内容                            |
  |--------------+-------------------------------------------------------------|
  |/proc/cmdline |加载kernel时所下达的相关指令与参数                            |
  |--------------+-------------------------------------------------------------|
  |/proc/cpuinfo |本机的CPU的相关信息，包含频率、类型与运算功能等                |
  |--------------+-------------------------------------------------------------|
  |/proc/devices |这个文件记录了系统各个主要装置的主要代号，与mknod有关          |
  |--------------+-------------------------------------------------------------|
  |/proc/filesys |目前系统已经加载的文件系统                                    |
  |tems          |                                                             |
  |--------------+-------------------------------------------------------------|
  |/proc/interrup|目前系统上面的IRQ分配状态                                     |
  |ts            |                                                             |
  |--------------+-------------------------------------------------------------|
  |/proc/ioports |目前系统上面各个装置所配置的I/O地址                           |
  |--------------+-------------------------------------------------------------|
  |/proc/kcore   |这个就是内存的大小，很大，最好不要去读取它                     |
  |--------------+-------------------------------------------------------------|
  |/proc/loadavg |top和uptime，上面的三个平均数值就是记录在此                   |
  |--------------+-------------------------------------------------------------|
  |/proc/memminfo+使用free列出的内存信息                                        |
  |--------------+-------------------------------------------------------------|
  |/proc/modules |目前我们的linux已经加载的模块列表，类似驱动程序                |
  |--------------+-------------------------------------------------------------|
  |/proc/mounts  |系统已经挂载的数据，就是用mount呼叫出来的数据                  |
  |--------------+-------------------------------------------------------------|
  |/proc/swaps   |到底系统挂载的内存在哪里。使用掉的partition就记录在此          |
  |--------------+-------------------------------------------------------------|
  |/proc/partiti |fdisk -l 会出现目前所有的partition，在这个文件当中也有记录     |
  |ons           |                                                             |
  |--------------+-------------------------------------------------------------|
  |/proc/uptime  |使用uptime会出现的信息                                       |
  |--------------+-------------------------------------------------------------|
  |/proc/version |核心的版本，就是用uname -a显示的内容                          |
  |--------------+-------------------------------------------------------------|
  |/proc/bus/*   |一些总栈的装置，还有USB的装置也记录在此                        |
  |--------------|-------------------------------------------------------------|

  现在就用cat来看看就行，不必深入了解。


  16.4.3 查询已开启文件或已执行进程开启之文件

  a.fuser：藉由文件（或文件系统）找出正在使用该文件的进程
  
  当我们向知道一个进程在启动过程中开启了多少文件，就可以使用fuser观察。
  fuser [-umv] [-k[i] [-signal]] file/dir
  选项与参数：
  -u：除了进程的PID之外，同时列出该进程的拥有者；
  -m：后面接的那个档名会主动地上提到该文件系统的最顶层，对umount不成功很有效；
  -v：可以列出每个文件与进程还有指令的完整相关性；
  -k：找出使用该文件/目录的PID，并试图以SIGKILL这个性能好给予该PID；
  -i：必须与-k配合，在删除PID之前会先询问使用者意愿；
  -signal：例如-1，-15等等，默认是SIGKILL（-9）。

  使用 fuser -uv /home结果后：
                      用户     进程号 权限   命令
/home/zcj:           zcj        6921 ..c.. (zcj)pipewire
                     zcj        6922 ..c.. (zcj)pipewire-media-
                     zcj        6931 ..c.. (zcj)dbus-daemon
                     zcj        6933 ..c.. (zcj)gvfsd
		     等等………………


  权限(ACCESS)代表的意义：
  c：此进程在当前的目录下（非次目录）；
  e：可被触发为执行状态；
  f：是一个被开启的文件；
  r：代表顶层目录(root directory)；
  F：该文件被开启了，不过在等待回应中；
  m：可能为分享的动态函式库。

  如果想要查阅某个文件系统底下有多少进程正在占用文家系统时，使用-m会很有帮助。
  fuser -uv /proc
  无法umount时，我们可以fuser -mki /home 删除占用该文件系统的进程。

  既然可以针对整个文件系统，也可以针对单一文件：
  查找/run底下属于FIFO类型的文件：
  find /run -type p:
  /run/rpc_pipefs/gssd/clntXX/gssd
  /run/user/1000/systemd/inaccessible/fifo
  /run/initctl
  ………………………………………………
  /run/systemd/inhibit/1.ref
  /run/systemd/sessions/2.ref
  /run/systemd/inaccessible/fifo

  然后根据上面fuser的使用方法，对其中一个文件使用：
  fuser -uv /usr/initctl:
                       USER        PID ACCESS COMMAND
  /run/initctl:        root          1 F.... (root)systemd
  通常系统的FIFO文件都会放置到/run下面。


  
  b.lsof：通过usernname列出被进程开启的文件档名
  
  相对于fuser是由文件或者装置去找出使用该文件或装置的进程，放过来说，如何查出某个进程开启或者使用的文件与装置，就是用lsof。

  lsof [-aUu] [+d]
  选项与参数：
  -a：多项数据需要【同时成立】才显示出结果,即是所有的参数都要符合；
  -U：仅列出Unix like系统的socket文件类型；
  -u：后面接username，列出该使用者相关进程所开启的文件；
  +d：后面接目录，亦即找出某个目录底下已经被开启的文件。



  c.pidof：找出某支正在执行的程序的PID
  
  pidof [-sx] program_name
  选项与参数：
  -s：仅列出一个PID而不列出所有的PID；
  -x：同时列出该program name可能的PPID那个进程的PID；


16.5 SELinux初探
  SELinux已经是个非常完备的核心模块，尤其是CentOS提供了很多管理SELinux的指令与机制。因此在整体架构上面是单纯且容易操作的。

  16.5.1什么是SELinux
  全名是【Security Enhanced Linux】，意义是安全强化的Linux。
  强化的是：

  a.当初设计的目标：避免资源的误用
  SELinux是由美国国家安全局(NSA)开发的，开发SELinux的原因是：很多企业发现通常系统出现问题的原因大部分都在与「内部员工的资源误用」所导致的，实际由外部发动的攻击方而没有这么严重。什么是「员工资源误用」？
  假如有个不是很懂的系统管理员为了自己设定方便，将网页所在目录/var/www/html/的权限设定为drwxrwxrwx，那么就代表所有进程可对该目录存取。假设你开启了WWW服务器软件，那么该软件的运行过程是可以写入该目录的，而该软件是对整个Internet提供服务的。只要有恶意的人接触这支程序，而且该进程提供了用户写入的功能，那么就可以对你的系统写入莫名奇妙的东西。
  SELinux是整合到核心一个模块，关于SELinux的相关说明可以参考：
  http://www.nsa.gov/research/selinux/
  
  也就是说：其实SELinux是在进行进程、文件等细部权限设定依据的一个核心模块。由于启动网络服务也是进程，因此刚好也能够控制网络服务能否存取系统资源的一道关卡。
  

  b.传统的文件权限与账号关系：自主式访问控制，DAC
  这种存取文件系统的方式被称为「自主式访问控制(Discretionary Access Control,DAC)」，基本上就是依据进程的拥有者与文件资源的rwx权限来决定有无存取的能力。
  但是DAC由几个困扰：
  
  （1）root具有最高的权限：如果不小心某支进程被有心人取得，且该进程属于root的权限，那么这支进程就可以在系统上进行任何资源的存取。
  （2）使用者可以取得进程来变更文件资源的访问权限：如果你不小心把某个目录的权限设定为777,由于对任何人的权限会g便称rwx，因此该目录就会被任何人任意存取。


  c.以政策规则订定特定进程读取特定文件：委任式访问控制，MAC
  为了避免资源误用的情况，SELinux导入了委任式访问控制(Mandatory Access Control)的方法。
  MAC可以针对特定的进程与特定的文件资源来进行权限的控管。也就是说，即是你是root，那么在使用不同的进程时，你所能取得的权限并不一定是root，而得要看当时该进程的设定而定。
  如此，我们针对控制的【主体】变成了进程而不是使用者。此外，这个主体进程也不能任意使用系统文件资源，因为每个文件资源也有针对该主体进程设定可取用的权限。如此，控件目就细的多了。
  但是系统进程，文件很多，一项一项控制就不太可能。所以SELinux也提供了一些预设的政策(Policy)，并在该政策内提供了多个规则(rule)，让你可以选择是否启用该控制规则。

  在委任式访问控制的设定下，进程的活动空间就会小很多。例如：WWW服务器软件要达成进程为httpd的程序，默认情况下，httpd仅能在/var/www/这个目录底下存取文件，如果httpd这个进程想要到其他目录去存取数据时，除了规则设定要开放外，目标目录也得要设定成httpd可读取的模式(type)才行。所以即使httpd被cracker取得了控制权，他也无权浏览/etc/shadow等重要的配置文件。


  16.5.2SELinux的运作模式
  SELinux透过MAC的方式控管进程。
  先总结上面的MAC模式：MAC控制的是主体的进程，而目标则是该进程能否读取的【文件资源】。
  
  a.主体(Subject)：SELinux主要想要管理的就是进程，因此你可以将【主体】更进程划等号。
  
  b.目标(Object)：主体进程能够存取的【目标资源】一般就是文件系统。因此这个目标项目可以跟文件系统划上等号。
  
  c.政策(Policy)：
  由于进程与文件数量庞大，因此SELinux会依据某些服务来制定基本的存取安全性政策。这些政策还有详细的规则(rule)来执行不同的服务开放某些资源的存取与否。
  。targetd：针对网络服务限制较多，针对本机限制较少，是预设的政策。
  。minimum：有target修订而来，仅针对选择的进程来保护。
  。mls：完整的SELinux限制，限制方面较为严格。
  
  新手先使用预设的targetd就行。
  
  d.安全性文本(security context)：
  主体与目标的安全性文本也必须一致才能够顺利存取。这个安全性文本(security context)类似文件系统的rwx。里面的内容与设定非常重要。如果设定错误，有些服务就无法存取文件系统，一直出现【权限不符】的错误信息。

  相关的工作流程：
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  还不会使用emacs，之后会了才来升级。
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  上图重点在【主体】如何取得【目标】的资源访问权限。由上图我们可以发现：（1）主题进程必须要通过SELinux政策内的规则放行后，就可以与目标资源进行安全性文本的对比；（2）若对比失败则无法存取不表，若对比成功则可以开始存取目标。
  问题是，最终能否存取目标还是与文件系统的rwx权限设定有关。

  。安全性文本（Security Contest）
  CentOS 7的target政策已经订制好非常多的规则，因此，新手的我们只要知道如何开启/关闭某项规则的放行与否即可。安全性文本就要我们自行配置了。安全性文本就类似rwx，只是SELinux内必备的rwx。
  安全性文本存在于主体进程中与目标文本资源中。进程在内存内，所以安全性文本可以存入是没问题的。那么文件的安全性文本是记录在那里？事实上，安全性文本是放置在文件的inode内的，因此主体进程想要读取目标文件资源时，同样需要读取inode，这inode内就可以比对安全性文本以及rwx等权限值是否争取，从而给予时的那个的读取权限依据。
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  这里不建议直接开启selinux，至少学完这一节在去下载，开启；或者使用虚拟机。我下载，开启后，开不了机，原因是selinux导致了我的挂载文件无法挂载，之后去单人维护模式将selinux改为permissive才开启了。
  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  安全性文本的样子：ls -Z
  system_u:object_r:user_home_t:s0 3-2.cpp
  system_u:object_r:user_home_t:s0 3_2.cpp
  system_u:object_r:user_home_t:s0 3_3.cpp
  system_u:object_r:user_home_t:s0 3_4.cpp

  如上所示，安全性文本主要使用冒号文为三段：
  Identify:role:type

身份识别：角色：类型

    （1）身份识别（Identify）：
    。unconfined_u：不受限的用户，也就是说，该文件来自于不受限的进程所产生的。一般来说，我们使用可登入账号来取得bash之后，预设的bash环境是不受SELinux管制的。因为bash并不是特别的网络服务。因此，在这个不受SELinux所限制的bash进程所产生的文件，其身份识别大多就是unconfined_u。
    。system_u：系统用户，大部分是系统自己产生的文件。
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    刚写到这里我就有个疑问，我在前面的我使用ps/0产生的文件都是systemd
    _u类型的。详情可以看前面的，那些都是cpp文件。当然也有可能是因为我
    是最近才装的SELinux，所以这些文件都是这个样子的。
    验证后，即从网上下载和自己生成的文件都是unconfined_u。而之前我产生的
    文件会是system_u是因为在那之前我的系统还没有安装SELinux。
    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    
    （2）角色（Role）：
    透过角色字段，我们可以知道这个资料属于进程、文件资源还是代表使用者。一般角色有：
    。object_r：代表的是文件或目录等文件资源。
    。system_r：代表的就是进程。不过一般使用者也会被指定成为system_r。
    
    （3）类型（type）：
    在预设的targetd政策中，Identify与Role字段基本上是不重要的。重要的是类型字段。基本上，一个主体进程能不能读取到这个文件资源，与类型字段有关。类型字段在文件与进程的定义不太相同，分别是：
    。type：在文件资源(Object)上面成为类型(Type)；
    。domain：在主体进程(Subject)则成为领域(domain)；
    
  
    我们先来了解主体进程在这三个字段的意义：
    ps -eZ
    LABLE                               PID TTY        TIME    CMD
    system_u:system_r:init_t:s0           1 ?        00:00:04 systemd
    system_u:system_r:kernel_t:s0         2 ?        00:00:00 kthreadd

    身份识别：unconfined_u |角色：unconfined_r：
    一般可登入使用者的进程。类似没有受限的进程。大多数都是用户已经顺利登入系统后，所用来操作系统的进程。如bash,X window相关软件等。

    身份识别：system_u|角色：system_r：
    由于为系统账号，因此是非交谈式的系统运作进程，大多数的系统进程据是这种类型的。

    如上所述，其实最终要的字段是类型字段(Type)，主体与目标之间是否具有可以读写的权限，与进程的domain及文件的type有关。可以通过/usr/sbin/cron，/etc/crontab，/etc/cron.d等文件来说明。

     ps -eZ |grep cron
     system_u:system_r:crond_t:s0-s0:c0.c1023 3043 ?  00:00:00 cron
     system_u:system_r:crond_t:s0-s0:c0.c1023 3240 ?  00:00:00 atd

     可以看到类型是crond_t。
     在来看看执行档，配置文件的安全文本内容：
     
     ll -Zd /usr/sbin/cron /etc/crontab /etc/cron.d
     drwxr-xr-x. 2 root root system_u:object_r:system_cron_spool_t:s0    60  7月 14 15:07 /etc/cron.d/
    -rw-r--r--. 1 root root system_u:object_r:system_cron_spool_t:s0  1136  8月  6  2021 /etc/crontab
    -rwxr-xr-x. 1 root root system_u:object_r:crond_exec_t:s0        51792  3月 23 21:49 /usr/sbin/cron*
    
     当我们执行/usr/sbin/cron之后，这个程序变成的进程的domain类型会是cron_t。而这个cron_t能够读取的配置文件则为system_cron_spool_t的类型。因此不论/etc/crontab，/etc/cron.d以及/var/spool/cron都会是相关的SELinux类型。
     实际执行：
     ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
     我还不会用emacs作图，因此，我以后再来修改。
     ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

     用文字描述：
     a.首先，我们触发一个可执行的目标文件，那就是具有crond_exec_t这个类型的/usr/sbin/cron文件；
     b.该文件的类型会让这个文件所造成的主体进程(Subject)具有cron这个领域(domain)，我们的政策针对这个领域已经执行了许多规则，其中包括这个领域可以读取的目标资源类型；
     c.由于cron domain被设定为可以读取system_cron_spool_t这个类型的目标文件(Object)，因此你的配置文件放到/etc/cron.d就能够被cron这支进程所读取；
     d.但最终能不能读取到正确的资料，还得看rwx是否符合Linux权限的规范。


     其上有几个重点：
     第一个是政策内需要制定详细的domain/type相关性；第二个是若文件的type设定错误，那么即使设定为rwx全开的777,该主体进程也无法读取目标文件资源。降低了资源误用的可能性。


     之后可以看相关的测试，鸟哥的相关位置就有。而且我这里也有进行测试，首先在打开日志功能后，在/etc/cron.d生成checktime文件，之后用ls -lZ看到其(Type)是system_cron_spool_t，说明其是可以读取的，同时日志文件也没有相关的信息。因此是可以成功使用的。与鸟哥书籍里面的有所不同。不同的原因是我是直接在/etc/cron.d里面生成的，其类型是system_cron_spool_t，而在/home/×××里面生成的类型就是user_home_t，在移动到/etc/cron.d里面的类型不变，所以会出现问题。
     因此类型是在文件产生时就出现，且不会随着移动而发生改变的。


  16.5.3 SELinux三种模式的启动、关闭与观察
  并非所有的Linux distributions都支持SELinux的，所以要自己观察自己的系统是否支持。我使用ubuntu22支持，但要自己下载。
  共有三种模式：
  。enforcing：强制模式，代表SELinux运作中，且已经正确的开始限制domain/type了；
  。permissive：宽容模式，代表SELinux运作中，不过仅会有警告信息并不会有实际限制domain/type的存取。这种模式可以运来作为SELinux的debug使用；
  。disabled：关闭，SELinux并没有实际运作。

  而在SELinux中并不是所有的进程都会被SELinux所管制，因此最左边会出现一个所谓「有受限的进程主体」。那如何观察有没有受限(confined)？透过ps -eZ。
   ps -eZ |grep -E 'cron|bash'
   system_u:system_r:crond_t:s0-s0:c0.c1023 2817 ?  00:00:00 cron
   system_u:system_r:crond_t:s0-s0:c0.c1023 2974 ?  00:00:00 atd
   unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 11306 pts/0 00:00:00 bash

   我们可以看到type这里有一个unconfined_t，也就是说bash这个命令没有受到SELinux的限制。
   三种模式的运作：
   Disabled：那么SELinux将不会运作，当然受限的进程也不会经过SELinux，也就是直接去判断rwx而已。
   permissive：不会将主体进程抵挡，不过万一没有通过政策规则，或者安全文本的对比时，那么该读写动作将会被记录起来，可作为未来检查问题的判断依据。
   Enforcing：就是实际将受限主体进入规则比对、安全文本比对的流程，若失败，就直接抵挡主体进程的读写行为，并且将他记录下来。如果通通没问题，这才进入到rwx的判断。

   查看SELinux的模式：
   getenforce：
   Permissive（这是我的电脑目前的情况）。

   如何知道SELinux的政策(Policy)：
   sestatus [-vb]
   选项与参数：
   -v：检查列于/etc/sestatus.conf内的文件与进程的安全性文本内容；
   -b：将目前政策的规则布尔值列出，以及某些规则(rule)是否要启动(0/1)之意；

   SELinux模式在enforcing或permissive之间切换的方法：
   setenforce [0|1]
   选项与参数：
   0：转成permissive
   1：转成Enforcing
   但是在我的系统中没有用。可能是没有重启，因为SELinux是整合到核心里面，所以要重启才能看到。刚才重启了，没有开启，即这个对于我的系统没有用。使用 man后，看到没有切换的能力。

   Tips：在某些特殊的情况下，从diabled切换成Enforcing之后，会有一堆的服务无法顺利启动，都会跟我们说在/lib/xxx里面的数据没有权限读取，所以启动失败。这大多数是由于在重新写入SELinux type(Relabel)出错的原因。使用Permissibe就没有这个错误，而处理方式就是：使用「restorecon -Rv /」重新还原所有SELinux的类型。
   ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
   千万不要随便使用Enforcing，反正我就是打开之后就开不了机器，很难的。
   真的不要去随意打开，要用就用虚拟机。
   ！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

  16.5.4SELinux政策内的规则管理
  如果进入Enforcing模式，那么接下来会影响到主体进程的，就是第二关：「target政策内的各项规则(rules)」。

  。SELinux各个规则的布尔值查询 getsebool
  getsebool [-a] [规则的名称]
  选项与参数：
  -a：列出目前系统上面的所有SELinux规则的布尔值为开关或关闭值

  。SELinux各个规则规范的主体进程能够读取的文件SELinux type查询 seinfo，sesearch：
  我们知道有很多规则，但是每个规则到底在限制什么？如果想知道，就要使用seinfo等工具。

    seinfo [-Atrub]
    选项与参数：
    -A：列出SELinux的状则、规则布尔值、身份识别、角色、类别等所有信息；
    -u：列出SELinux的所有身份识别(user)种类；
    -r：列出SELinux的所有角色(role)种类；
    -t：列出SELinux的所有类别(type)种类；
    -b：列出所有规则的种类（布尔值）；

    sesearch [-A] [-s 主体类别] [-t 目标类别] [-b 布尔值]
    选项与参数：
    -A：列出后面数据中，允许「读取或放行」的相关数据；
    -t：后面还要接类别，例如 -t httpd_t；
    -b：后面还要接SELinux的规则，例如 -b httpd_enable_ftp_server；
    
    主体类别指的是【主体（进程）】的类型（type）；
    目标类别：【目标（文件或目录）】的类型（type）；
    布尔值：指的是政策下的规则（rule）的布尔值；

    sesearch -A　-s crond_t |grep spool：
    allow crond_t cron_spool_t:dir { add_name getattr ioctl lock open read remove_name search watch write };
    allow crond_t cron_spool_t:file { append create getattr ioctl link lock open read rename setattr unlink write };
    allow crond_t cron_spool_type:file { getattr ioctl lock open read };
    allow crond_t system_cron_spool_t:dir { getattr ioctl lock open read search watch };
    ……………………………………………………………………………………………………………………

    在上面的数据中，我们使用-s来查询进程为crond_t可以读取文件，在用spool作为筛选的关键字，得到的数据，就是crond_t可以读取的文件的type，后面括号里面的是能够做的操作。


    我们看看httpd_enable_homedirs到底是什么：
    使用semanage：
    semanage boolean -l |grep httpd_enabled_homedirs
    httpd_enable_homedirs          (off  ,  off)  Determine whether httpd can traverse user home directories.
    这里可以看到这个规则的确可以使httpd的类型的进程去读取读取目录。

    使用sesearch -A　-b httpd_enabled_homedirs 可以该规则下面所有的主体与目标之间的关系。
    sesearch -A -b httpd_enabled_homedirs |grep user_home_dir_t：
    allow httpd_suexec_t user_home_dir_t:dir { getattr open search }; [ httpd_enable_homedirs ]:True
    allow httpd_sys_script_t user_home_dir_t:dir { getattr open search }; [ httpd_enable_homedirs ]:True
    allow httpd_t user_home_dir_t:dir { getattr open search }; [ httpd_enable_homedirs ]:True
    allow httpd_user_script_t user_home_dir_t:dir { getattr open search }; [ httpd_enable_homedirs ]:True


  。修改SELinux规则的布尔值 setsebool
  setsebool [-P] [规则名称] [0|1]
  选项与参数：
  -P：直接将设定值写入配置文件，该设定数据未来会生效的；


  16.5.5SELinux安全文本的修改
  我们要学会自己修改文件的type以达到让文件可以被正确的读取。
  使用chcon手动修改文件的SELinux type
  chcon [-R] [-t type] [-u user] [-r role] 文件
  chcon [-R] --reference=范例文件 文件

  选项与参数：
  -R：连通该目录下的次目录也同时修改；
  -t：后面接安全性文本的类型字段。
  -u：后面接身份识别，例如system_u；
  -r：后面接角色，录入system_r；
  -v：若有变化成功，请将变动的结果列出来；
  --reference=范例文件：将某个文件当范例来修改后续接的文件的类型。

  但是这个方式有一些问题，因为我们要知道文件需要的类型，或者文件应该存储的位置，不过我们可以让SELinux自己解决默认目录下的SELinux type。

   。使用resrorecon让文件恢复正确的SELinux type
   restorecon [-Rv] 文件或目录
   选项与参数：
   -R:连通次目录一起修改；
   -v:将过过程显示到屏幕上。

   。semanage默认目录的安全性文本查询与修改
   那么restorecon为什么可以「恢复」原本的SELiux type？因为有个地方记录每个文件/目录的SELinux的默认类型。那么我们要如何查询预设的SELinux type以及如何增加/修改/删除预设的SELinux type。
   semanage {login|use|port|interface|fcontext|translation} -l
   semanage fcontext -{a|d|m} [-first] file_spec
   选项与参数：
   fcontext：主要用在安全性文本方面的用途，-l为查询的意思；
   -a：增加的意思，你可以增加一些目录的默认安全性文本类型设定；
   -m：修改的意思；
   -d：删除的意思；
   
  























































































    



























































































  

  
  







  

  
  

  


       
       
