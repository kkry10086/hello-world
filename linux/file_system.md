由于每种操作系统的文件权限/属性不同，所以每次磁盘分区后，都要
对硬盘格式化，已成为操作系统可以使用的文件系统格式。

而文件系统从一开始就将inode与数据区块规划好了，除非重新格式化
(或利用resize2fs等命令修改其大小)，否则inode与数据区块固定好
后就不再变动。


现在的操作系统的文件除了文件的实际内容，还有文件的权限，属性等。
文件系统通常会将这两部分的数据分别存放在不同的区块，权限，属性
放置到inode中，至于实际数据则放置到数据区块中。

超级区块(super block)会记录整个文件系统的整体信息，包括inode与
数据区块的总量，使用量，剩余量。

超级区块:记录此文件系统的整体信息，包括inode与数据区块的总量，
         使用量，剩余量，以及文件系统的格式与相关信息等。

inode:   记录文件的属性，一个文件占用一个inode，同时记录此文件
         的数据所在的区块号码。

数据区块: 实际记录文件的内容，若文件太大时，会占用多个区块。

(碎片化整理:需要碎片化处理的原因就是文件写入的区块太过于离散，此时
           文件读取的性能将会变得很差所致。这时候，通过碎片化整理
	    将同一个文件所属的区块集合在一起，这样数据的读取就会
	    比较容易。这经常用于FAT的文件系统。)

ext2: 硬盘很大时，inode与数据区块就会很多，不利于管理。因此，ext2
      格式化时是区分为多个区块群组(block group)。每个区块群组都有
      独立的inode，数据区块，超级区块系统。(硬盘的主要/扩展分区
      就是一个文件/操作系统,里面有多个block group)
      


block group: 六个主要内容:

1. 数据区块(data block):
   数据区块是用来放置文件数据的地方，硬盘的区块大小在格式化时就已经固定了。
   原则上，区块的大小与数量在格式化完就不能给够在修改(除非重新格式化);
   每个区块最多只能够放置一个文件的数据;
   承上,如果文件大于区块大小,则一个文件会占用多个区块数量;
   承上,若文件小于区块,则该区块的剩余容量就不能够在被使用了(磁盘空间会浪费)。



2. inode table(inode 表):
   inode记录的数据至少有下面这些:
     .该文件的读写属性(read,write,exeute);
     .该文件的拥有者与用户组(owner,group);
     .该文件的大小;
     .该文件建立或状态改变的时间(ctime);
     .最近一次读取时间(atime);
     .最近修改的时间(mtime);
     .定义文件特性的标识(flag),SetUid,SetGid,SBIT;
     .该文件内容的真正指向(point);
     inode 的数量和大小也是在格式化时就固定了;
     .每个inode的大小固定为128B,(最近的ext4与xfs可设置到256B);
     .每个文件都仅会占用一个inode;(important:即一个inode指向一个文件);
     .承上,因此文件系统能够建立的文件数量与inode的数量有关;
     .系统读取文件时需要先找到inode,并分析inode记录的权限与用户是否
      符合,若符合才能够读取区块的内容;


    inode要记录的信息很多,而一个区块就要4B,那么满打满算128/4=32区块,
    按最大来计算(4K)计算,那么一个inode最多记录一个128K的文件,这很明显
    是远远不够的.因此,系统将inode记录区块号码的区域定义为12个直接,一个
    间接,一个双间接和一个三间接记录区(all:15).


    间接记录区就是再拿一个区块来当作记录区块号码的记录区,如果文件太大,
    就会使用间接的区块来记录编号;(一层);
    双间接:就是第一层的间接区块不是直接指向文件的位置,而之指向第二层的
    区块(直接记录文件的位置);(两层);
    三间接(以此类推);

    那么一个inode最多能够记录的文件大小(以区块为1k来说明):
    12K+(1k/4B)*k+
    [(1k/4B)*(1K/4B)]*k+
    {[(1k/4B)*(1K/4B)]*(1k/4B)}*k
   =12*1K+256*1k+
    256*256*1k+
    256*256*256*1K
   =(12+2^8+2^16+2^24)k
   =12k+256k+64M+16GB


3. Superblock(超级区块):
   记录整个文件系统相关信息的地方,没有超级区块就没有文件系统.
   记录的信息主要有:
   .数据区块与inode的总量;
   .未使用与以使用的inode与数据区块的数量;
   .数据区块与inode的大小(block : 1k,2k,4k,indoe : 128B,256B);
   .文件系统的挂载时间,最近一次写入数据的时间,最近一次校验磁盘
    (fdisk)的时间等文件系统的相关信息.
   .一个有效为数值,若此文件系统以被挂载,则有效位为0,否则,为1;
   dumpe2fs
   
    每个区块群组(block group)都可能含有超级区块.但是一个文件系统
    应该仅有一个超级区块而已.事实上,除了第一个区块群组内会含有
    超级区块之外,之后的的区块群组不一定含有超级区块,若有超级区块,
    则该超级区块主要是第一区块区组的超级区块的备份,这样可以进行
    超级区块的恢复.
    


4. Filesystem Description(文件系统描述说明)
   每个区段可以描述每个区块群组的的开始与结束区块,以及说明每个区段
   (超级区块,对照表,inode对照表,数据区块)分别介于哪一块区块之间.
   dumpe2fs

5. 区块对照表(block bitmap):
   新增文件总会用到区块,那就要用到空闲区块,那么我们要怎么知道哪个
   区块是空的?这就要通过区块对照表的辅助了.从区块对照表当中可以
   知道那些区块是空的,因此,我们的系统就能够快速的找到可使用的区块
   来处理文件.
   similarly,如果你删除某些文件的话,那么那些文件占用的区块号码就
   释放出来,此时在区块对照表中对应到该区块号码的标志就要修改成为
   [未使用中],这就是对照表的功能.

6. inode对照表(inode bitmap):
   与区块对照表类似,就是对象改成了inode.

7. dumpe2fs:查询ext系列超级区块信息的命令.(自己的是ext4)
   


二、目录树:
   我们家里一个目录时，文件系统会分配一个inode与至少一个数据区块给该
   目录。其中inode记录该目录的相关权限与属性，并可记录分配的那块区块
   号码;而区块则是记录在这个目录下的文件名与该文件名占用的inode号码
   数据。

linux文件系统的运行:
   linux使用异步处理(asynchronuosly)的方式:
   当系统加载了一个文件到内存后，1.如果文件没被修改过，则在内存区段的
   文件数据会被设置为【clean】。但如果内存中的文件数据被更改过了，此时
   该内存中的数据会被设置为【dirty】，此时所欲的操作都还在内存中运行，
   并没有写入到硬盘中。系统会不定时地将内存中设置为【dirty】的数据写回
   硬盘。

三、挂载点的意义(mount point)：
   挂载点一定是目录，该目录为进入该文件系统的入口。
   同一个文件系统的某个inode只会对应到一个文件内容，一个文件占用一个
   inode，一个或多个的数据区块。


四、linux支持的文件系统与VFS：
   .传统文件系统：ext2，minix,FAT(用vfat模块).iso9660(光盘)；
   .日志式文件系统：ext3/4,ReiserFs,Windows'NTFS,IBM'sJFS,zfs;
   .网络文件系统：NFS,SMBFS;

   Linux VFS (virtual filesystem switch):
   所有的linux系统都是通过一个名为VFS的内核功能去读取文件系统。也就是说：
   整个Linux识别的文件体统其实都是VFS再进行管理，我们用户不需要知道每个
   硬盘分区上面的文件体统是什么，VFS会主动帮我们做好读取的操作。


五、XFS文件介绍：
   ext系列叫伤脑筋的地方：支持度最广，但格式化超慢。
   ext系列对于文件格式化的处理方面，采用的是预先规划出所有的inode，区块，
   元数据等数据，未来可以直接使用，不需要再进行动态配置的做法。
   现在的硬盘容量越做越大，当ext系列做TB级别以上的文件系统的格式化的时候，
   光是系统预先分配inode与区块就要很多时间。

   .XFS文件系统的配置：
   xfs的文件系统在数据的分布上，主要规划三个部分：
   .数据区(data section)
   .文件系统活动登陆区(log section)
   .实时运行区(realtime section)

   1.数据区：
   和ext系列几乎一样，分为多个区块群组，且有inode,data block, super block
   等等，但是，inode与区块都是系统需要用到时才会动态配置产生，所以格式化
   操作非常快。
