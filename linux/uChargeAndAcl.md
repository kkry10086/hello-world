13章   linux账号管理与ACL权限设置

13.1 Linux的账号与用户组
   linux主机不认识账号,只认识ID,所以我们用户的信息都是通过ID来找到的，而相应的信息
   就写在/etc/passwd里面。通过UID获得相应的账号名。如果没有对应的账号名，则只会出现
   UID。
   登陆时就是用账号名来获得相应的UID的权限，所以这里要小心，否则很可能连登陆都不行。

   13.1.1 用户标识符:UID 与 GID
   每个人登陆时至少都会获得两个ID,一个是用户ID(UID),另一个是用户组ID(GID);


   13.1.2 用户账号：2
   linux系统上面的用户登陆主机以获得shell的环境来工作，进行的方式：
   在计算机面前利用tty1-ttyn(n各个主机并不相同)，输入账号与密码后才能够登陆。
   这里只谈了本地登陆。

   你输入账号密码后，系统做了什么：
   1.先查找/etc/passwd里面是否有你输入的账号，如果没有就退出；如果有，则将该账号的
     对应的UID与GID（/etc/group）读出来，另外，该账号的家目录与shell设置也一并读
     出来。


   2.再来则是核对密码表。这时Linux会进入/etc/shadow里面找出对应的账号与UID，
     然后核对一下你刚刚输入的密码与里面的密码是否相符。


   3.如果一切都ok，就进入shell管理的阶段。


   。/etc/passwd文件结构
   每一行都代表一个账号，有几行就代表有几个账号在你的系统中。而里面有很多的账号本来
   就是系统正常运行所必须的，这些简称为系统账号。

   head -n 4 /etc/passwd:
   root:x:0:0:root:/root:/bin/bash
   daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
   bin:x:2:2:bin:/bin:/usr/sbin/nologin
   sys:x:3:3:sys:/dev:/usr/sbin/nologin

   每一行由：来分割区域，每一行由7个区域
   1.账号名称：
   提供给对数字不太敏感的人使用来登陆系统。
   2.密码：
   早期UNIX系统的密码就是放在这字段上。但是因为这个文件的特性就是所有的程序都能够
   读取到，这样就容易造成密码数据被盗窃，因此后来就将这个字段的密码数据放到/etc/
   shadow里面。
   3.UID
   用户标识符。通常，linux对UID有几个限制：
------------------------------------------------------------------------------
   id范围    |  用户特性
----------------------------------------------------------------------------
   0         |当UID是0时，代表这个账号是【系统管理员】，所以要让其他的账号名称也具
系统管理员    |有root的权限时，将该账号的UID改为0即可。也就是说，一台系统上面的
	     |系统管理员不见得只有root。
------------------------------------------------------------------------------
1-999        |保留给系统使用的ID，其实除了0之外，其他的UID权限与特性并没有不一样。
（系统账号）  |由于系统上面启动的网络服务或后台服务希望使用较小的权限去运行，因此
	     |不希望使用root的身份去执行这些服务，所以我们要提供这些运行中程序的
	     |拥有者账号才行。这些账号通常不可登陆，使用/usr/sbin/nologin.
	     |1-200: 有；linux发行版自行建立的系统账号
	     |201-999：若用户有系统账号需求时，可以使用的账号ID
----------------------------------------------------------------------------
 1000-60000  |给一般用户使用，实际上，linux内核（3.10x版）已经可以达到
（可登录账号） |4294867295=2^32-1
---------------------------------------------------------------------------
   

   4.GID
   与/etc/group相关，与/etc/passwd差不多，只是它仅仅是用来规范组名与GID的对应而已。


   5.用户信息说明栏：
   没什么用途，只是用来解释这个账号的意义而已。不过，如果你提供finger的功能时，这个
   字段可以提供很多的信息。用chfn命令来解释。


   6.家目录：
   就是登录时，会在哪个目录里面出现。想要改变自己出现的目录，就改这里。


   7.shell：
   每个账号登陆时使用的默认shell。不过有一些账号在登陆时无法获得shell环境，就是
   /sbin/login。


   。/etc/shadow文件结构
   以前的账户密码是在/etc/passwd里面，虽然加密了，但是仍然有被解开的风险。于是
   就把密码移动到/etc/shadow里面来分割开来的技术。而且还加入很多的密码限制参数在
   /etc/shadow里面。

   root:$6$M0MNOkGp$EfmrwZWkmqtRo9THp/jlQmYoGftPXklIoYVv.IxoZsZstOqZTv.j
   n1L4QAlqhWL90tDz1nC5kc7hIgfjVK..h/:19127:0:99999:7:::
   daemon:*:18885:0:99999:7:::
   bin:*:18885:0:99999:7:::
   sys:*:18885:0:99999:7:::
   sync:*:18885:0:99999:7:::
   共九个字段；

   1.账号名称：
   由于密码也需要账号对应，因此第一个就是账号。


   2.密码：
   这个字段内的数据才是真正的密码，而且是经过编码的密码（摘要）。不过，只要获得了
   r的权限就可以得到密码，同样可以破解。所以要小心权限，不能让root以外的人有权限。
   这个字段的长度一般都是固定的，因为使用的是固定的密钥算法。


   3.最近修改密码的日期：
   这个字段记录了【修改密码那一天】的日期。不过这里的数据不会是我们常用的YYYYmmDD
   的形式，而是用modify day-1970/01/01的天数。


   4.密码不可被修改的天数（与第三段相比）：单位是天数
   
   5.密码需要重新修改的天数（与第三段相比）：单位是天数
   必须在这个天数你被重新设置你的密码，否则这个账号的密码将会变为过期性质。
   当然，过了时间，你登录还是可以的，但是系统会强制要求你重新设置密码，才能继续
   使用。


   6.密码需要修改期限前的警告天数（与第5段相比）：单位是天数


   7.密码过期后的账号宽限时间（密码失效日，与第5段相比）：单位是天数
   一旦过了这个时间，密码将会失效，账户将无法通过该账号与密码登陆。

   8.账号失效日期（与第三段一样，与1970/01/01相比）：
   这个字段表示：这个账号在此字段规定的日期之后，将无法在使用。就是所谓的【账号失效】，
   此时，无论密码过期与否，都无法再次使用。一般用在收费服务的系统中。


   9.保留：还没决定用来干啥。



   现在讲一下两种情况：
   1.一般用户密码忘记了：
   请系统管理员重新设置密码

   2.root密码忘记了：
   这个就很麻烦了。这时就要使用各种可行的方法启动进入linux修改。
   例如：重新启动进入单人维护模式（19章）后，系统会主动给予root权限的bash接口，此时
   再以passwd修改密码即可。或是用Live CD启动后挂载根目录去修改/etc/shadow，将里面
   的root的密码字段清空，在重新启动后root不用密码即可登陆，登录后，要赶快用passwd
   命令设置root密码即可。


   查看shadow使用的加密的机制时：
   authconfig --test |grep hashing


   13.1.3关于用户组：有效与初始用户组，groups,newgr
   。/etc/group的文件结构:

   root:x:0:
   daemon:x:1:
   bin:x:2:
   sys:x:3:

   1.组名
   
   2.用户组密码
   通常不需要设置，这个设置通常是给【用户组管理员使用】，目前很少有这个机会设置用户
   组管理员。密码已经移动到/etc/gshadow里面。
   
   3.GID
   
   4.此用户组支持的账号名称
   一个账号是支持多个用户组的，如果某个账号想要加入此用户组时，就将该账号填入这个字
   段，用"，"来做分隔，不能有空格。现在的linux的版本已经不会将初始用户组的用户群
   加入到第四段了。


   。有效用户组(effective group)与初始用户组(initial group)：
   每个用户在他的/etc/passwd里面第四栏有GID，这个GID就是【初始用户组(inttial
   group)】。也就是说，当用户一登录系统，就立刻拥有这个用户组的相关权限。
   而在对已有文件的操作中，只要是属于的用户组，就可以拥有用户组的权限。

   但是，有一个问题：创建文件时，我们使用的用户组是什么？
   这时候就要检查有效用户组(effictive group)了。

   groups:有效与支持用户组的观察
   groups 可以得到用户支持的用户组的信息
   
   zcj adm cdrom sudo dip plugdev lpadmin sambashare
   第一个输出的用户组即为有效用户组【effictive group】；


   newgrp：有效用户组的切换
   想要切换的用户组必须是你已经支持的用户组。
   newgrp  gname(用户组名)

   newgrp这个命令可以修改目前用户的有效用户组，而且是另外以一个shell来提供这个功能。
   事实就是当前用户用另一个shell登陆，而且新的shell会给予当前用户有效用户组为gname。
   此时用户的环境设置不会有影响。


   加入用户组的方式有两个：
   1.通过系统管理员（root）利用usermod帮你加入；
   2.如果root太忙了，而且你的系统有设置用户组管理员，那么你可以用过用户组管理员以
   gpasswd帮你加入它所管理的用户组。


   。/etc/gshadow

   root:*::
   daemon:*::
   bin:*:: 
   sys:*::
   adm:*::syslog,zcj

   1.组名
   2.密码栏，同样的开头是！表示无合法密码，所以无用户组管理员
   3.用户组管理员的账号（gpasswd 会介绍）
   4.有加入该用户组支持的所属账号（与/etc/group一样）

   以系统管理员的角度来说，/etc/gshadow的最大功能就是建立用户组管理员。
   用户组管理员：由于系统上面账号可能很多，有事可能太忙碌，此时有人想要加入某个用户组，
   但是没时间。此时该用户组管理员就能够将那个账号加入自己管理的用户组。不过由于有
   sudo这个工具，减少了用户组管理员的功能的使用。


13.2账号管理：

   13.2.1 新增与删除用户：useradd,相关配置，passwd，usermod,userdel
   我们登陆系统时需要账号与密码，所以建立新的账号时也需要有账号与密码
   账号可以用useradd来新建，密码则使用passwd来设置：

   。useradd：
   useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] \
   [-d 家目录绝对路径] [-s shell] 使用者账号名

   -u : 接UID，是一组数字，直接指定一个特定的UID给这个账号
   -g : 后面接的用户组就是初始用户组，该用户组的GID会放在第四栏
   -G : 后面接的用户组是该账号还可以加入的用户组，这个选项会修改/etc/group的内容
   -M : 强制，不要建立使用者目录。（系统账号默认值）
   -m : 强制，要建立使用者目录。（一般用户默认值）
   -c : 这个就是第5栏的内容
   -d : 指定某个目录成为家目录，而不是使用默认值，务必使用绝对值
   -s : 后面接一个shell,没有则默认为/bin/bash
   -e : 后面接一个日期【YYYY-MM-DD】，此选项内容会写入/etc/shadow里面第8栏，
        表示账号失效日
   -f : 后面接/etc/shadow的第七栏选项,指定密码是否会失效。0为立刻失效，
        -1为永不失效。


   useradd会帮我们处理下面几个选项：
   在/etc/passwd 里面建立一行与账号相关的数据，包括UID/GID/家目录等、
   在/etc/shadow里面将此账号的密码相关参数写入，但是尚未有密码
   在/etc/group里面加入一个与账号名称一模一样的组名（前提是没有自己设置一个已经\
   存在的用户组作为用户组）
   在/home下面建立一个与账号同名的目录作为用户家目录，每个系统设置不同，这个
   也不一定。


   useradd -r name 建立一个系统账号（system account）
   由于系统账号主要是用来执行系统所需服务的权限设置，所以系统账号默认都不会主动建立
   家目录。且系统账号的UID与GID都小于1000.

   useradd -D这个命令可以查看默认值，数据是从/etc/default/useradd调出来的。

   GROUP=100
   HOME=/home
   INACTIVE=-1
   EXPIRE=
   SHELL=/bin/sh
   SKEL=/etc/skel
   CREATE_MAIL_SPOOL=no

   GROUP=100新建账号的出事用户组使用GID为100。
   在linux里面默认用户与用户组的名字相同，为何会这样是因为针对用户组的角度有两种机制：

   。私有用户组机制：
     系统会建立一个与账号一样的用户组给用作为初始用户组。这种用户组设置机制比较有保密
     性，这是因为用户都有自己的用户组，家目录权限设置为700，这种机制不会考虑GROUP=100
     这个设置值。


   。公共用户组机制：
     就是以GROUP=100这个设置值作为新建账号的初始用户组，因此每个账号都属于users这个
     用户组，且默认家目录是【drwxr-xr-x】。

   注意：在ubuntu18里面就不同了。在私有制的情况下，做到机制为【drwxr-xr-x】。


   HOME=/home:用户家目录的基准目录（basedir）
   会使用与账号相同的目录，且会变成/home/sample

   INACTIVE=-1密码过期后是否会失效的设置值。
   这个设置值将会影响到密码过期后，在多久时间可以使用旧密码登陆。

   EXPIRE-：账号失效日期

   SHELL=/bin/sh:默认使用的shell程序文件名

   SKEL=/etc/skel: 用户家目录参考基准目录
   这个东西就是指定用户家目录的参考基准目录。当你建立新账户时，这个就可以作为家目录
   和shell参考来使用。

   CREATE_MAIL_SPOOL=yes:建立用户的mailbox
   使用 【ll /var/spool/mail/username】看一下，会发现有这个文件的存在，就是用户
   的邮箱。
   
   UID/GID的密码参数又是在哪里参考？/etc/login.defs
   这个文件里面包含的信息更加的多，详细。关于创建用户时使用的默认值。
   例如关于UID的最小/大值，密码必须修改时限，警告时限，最小长度，所以在建立前可以
   来这里看看，详细的默认值。
   因此useradd在建立账户时，参考了：
   /etc/default/useradd
   /etc/login.defs
   /etc/skel/*


   。passwd
   所有人都可以使用
   passwd [--stdin] [账号名称]
   只有root可以使用
   passwd [-l] [-u] [--stdin] [-S] [-n 日数] [-x 日数] [-w 日数] [-i 日期] 账号

   --stdin ：可以通过来自前一个管道的数据，作为密码输入，对shell脚本有帮助。
   example：
          echo "fu8923sdkj" | passwd --stdin usern
   好处是可以在脚本中大量使用来建立大量的账户。坏处是，会在命令行中，留下命令，
   一旦系统被攻破，不需要解密/etc/shadow里面的数据，就可以拿到想要的信息。
   （--stdin并不是每个版本【distribution】都有。）
   
   -l ：是lock的意思，会将/etc/shadow第二栏最前面加上!，使密码失效
   -u : 与-l相对，是unlock的意思。
   -S ： 列出密码相关参数，即shadow文件内的大部分信息。
   -n ：shadow第四栏，多久不能修改密码
   -x ：shadow第五栏，多久内必须修改密码
   -w ：shadow第六栏，密码过期前的警告天数
   -i ：接的是【日期】，shadow第七栏，密码失效日期。

   新的distributions使用较严格的PAM模块来管理密码，这个管理机制写在
   /etc/pam.d/passwd当中。而该文件与密码有关的测试模块就是使用：pam_cracklib.so，
   这个模块会检验密码相关的信息，并且取代/etc/login.defs内的PASS_MIN_LEN的设定。

   如果不想让某个人登陆系统，那么我们可以让其/etc/shadow的密码栏前面加上!!。可以
   使用：passwd -l usern
   之后使用passwd -S usern 查看情况

   。chage
   比passwd -S 更加详细地显示密码参数显示功能。

   chage [-ldEImMW] 账号名
   -l ：列出该账号的详细密码参数；
   -d ：后面接日期，修改shadow第三字段（YYYY-MM-DD）
   -E ：后面接日期，修改shadow第八段（账号失效日）（YYYY-MM-DD）
   -I ：后面接天数，修改shadow第七字段(密码失效日)
   -m ：后面接天数，修改shadow第四段（密码最短保留天数）
   -M ：后面接天数，修改shadow第五四段（密码多久必须进行变更）
   -W ：后面接天数，修改shadow第六段（密码过期前的警告日期）

   chage有一个不错的功能：让使用者第一次登陆时，强制他们一定要更改密码后才能够使用系统
   资源。
   将密码的最近一次的修改时间改为当前时间，此时，该用户登录时就一定要修改密码。


   。usermod
   修改/etc/passwd 和/etc/shadow
   usermod [-cdegGlsuLU] 账号名称
   -c ：后面接账号的说明，/etc/passwd第五栏
   -d ：后面接账号的家目录，修改/etc/passwd第六栏
   -e ：后面接日期，/etc/shadow第八栏，账号失效日，（YYYY-MM-DD）
   -f ：后面接天数，为/etc/shadow第七栏，密码失效日
   -g ：后面接初始用户组，修改/etc/passwd的第四个字段GID
   -G ：后面接次要用户组，修改这个使用者能够支持的群组
   -a ：与【-G】何用，可增加次要群组的支持，并非设定
   -l ：后面接账号名称，可修改账号名称，/etc/passswd
   -s ：后面接shell的实际问及那，/etc/passwd第7栏
   -u ：后面接UID数字，即/etc/passwd第三栏，
   -L ：暂时将用户的密码冻结，让他无法登陆
   -U ：将/etc/shadow密码栏的!拿掉，解冻


   。userdel
   删除用户的相关数据：

    1.用户账号/密码相关参数： /etc/passwd，/etc/shadow
    2.使用者群组相关参数： /etc/group，/etc/gshadow
    3.用户个人文件数据： /home/username， /var/spool/mail/username

   userdel [-r] username
   -r：连同用户的家目录也一起删除
   userdel是确定不要让该用户在主机上面使用任何数据。但是只要在这个系统上面使用了
   一段时间，那么就会导致其他地方也有相关用户的文件，因此在删除用户之前，先将那些
   文件占了。find / -user username



   13.2.2 用户功能
   一般用户也能够使用的功能：

   。id
   id可以查询某人或自己的相关UID、GID等信息。
   id [username]


   . finger
   可以查阅很多用户相关的信息。大部分是在/etc/passwd里面的信息。不过这个指令有点
   危险。现在默认不安装。

   finger [-s] username
   -s ：仅列出用户的账号，全名，终端机代号与登陆时间等等
   -m ：列出与后面接的账号相同者，而不是利用部分比对（包括全名部分）


   。chfn 有点像是change finger的意思
   chfn [-foph] [账号名]
   -f ：后面接完整的大名
   -o ：你办公室的房间号码
   -p ：办公室的电话号码
   -h ：家里的号码

    这些数据实质是修改到了/etc/passwd的第五栏，即用户的信息栏目。

   。chsh :change shell
   chsh [-ls]
   -l ：列出目前系统上面可用的shell，其实就是/etc/shells里面的内容
   -s ：设定修改自己的shell


   13.2.3 新增与移除群组
   群组的内容跟简单，基本就是/etc/group,/etc/gshadow两个文件的额新增，修改与移除而已。
   
   。groupadd
   groupadd [-g gid] [-r] 组名
   -g ：后面接某个特定的GID，用来直接基于某个GID
   -r ：建立系统群组，与/etc/login.defs内的GID_MIN有关
   也有人建议：新建的与使用者私有群组无关的其他群组时，使用小于1000以下的GID为宜。
   这就见仁见智。


   。groupmod与usermod相似，这个指令仅是在group相关参数的修改
   groupmod [-g gid] [-n group_name] 群组名
   -g ：修改既有的GID数字
   -n ：修改既有的组名
   不要随意更改GID，会造成系统混乱。


   。groupdel
   groupdel [groupname]     删除群组
   而且只能删除不是任何账号的initial group（初始群组）的群组。

   。gpasswd：群组管理员功能
   群组管理员可以管理哪些账号可以加入/移除该群组。
   root建立群组管理员
   gpasswd groupname
   gpasswd [-A user1,...] [-M user3,...] groupname
   gpasswd [-rR] groupname
   若没有参数，表示基于groupname 一个密码
   -A ：将groupname的主控权交由后面的使用者管理
   -M ：将某些账号加入这个群组
   -r ：将groupname的密码移除
   -R ：让groupname的密码栏失效


    群组管理员的动作：
    gpasswd [-ad] user groupname
    -a ：将某位使用者加入到groupname这个群组；
    -d ：将某位使用者移除到groupname这个群组；


    13.2.4账号管理实例
    自己看书；这里有一个问题，
    就是在目录ppp（2770，用户组：pro；用户组下：u1,u2,u3),我们要让u1能够查阅
    ppp，但是又没有修改权限。该怎么办好呢？
    此时，将u1踢出pro，在将目录改为（2775），此时u1确实做到了可以查阅，但没法
    修改的情况，但是这时其他所有人都又了查阅的能力。
    这个时候就要用到外部身份认证系统；


   13.2.5 使用外部身份认证系统
   使用外部的身份验证服务器提供的验证身份的功能。
   centos提供了一个名为authconfig-tui的指令给我们参考。



13.3 主机的细部权限规划：ACL的使用
（顺带一提，ACL的权限是低于传统权限的）

linux的权限很重要，但是传统的权限仅有三种身份（owner,group,others）搭配三种权限
（r,w,x）。并没有办法单纯地针对某一个使用者或某一个群组来设定特定的全新需求。


   13.3.1什么是 ACL 与如何支持启动 ACL
   ACL 是 Access Control List 的缩写，主要的目的是在提供传统的owner,group,others
   的r,w,x权限之外的细部权限设定。ACL 可以针对单一使用者，单一文件或目录来进行r,w,x
   的权限规范，对于需要特殊权限的使用状况非常又帮助。

    ACL主要针对那些方面来控制权限：
    使用者（user）：可以针对使用者来设定权限
    群组（group）：针对群组为对象来设定其权限
    默认属性（umask）：还可以针对在该目录下在建立新文件/目录时，规范新数据的默认权限；

    也就是说，如果有一个目录，需要给一堆人使用，每个人或每个群组所需要的权限并不相同时，
    在过去，传统的linux三种身份三种权限是做不到的，因为，传统的linux的权限只能针对
    一个用户，一个群组以及非此群组的其他人设定权限而已。ACL 就是为了解决这个问题。

    。如何启动 ACL
    事实上，原本 ACL 是unix-like 操作系统的额外支持项目，但因为仅限来linux系统对
    权限细部设定的热切需求，因此目前 ACL 几乎已经预设加入在所有常见的linux文件系统
    的挂载参数中。所以现在可以直接使用。
    dmesg | grep -i acl 可以查看是否支持ACL


    13.3.2 ACL 的设定技巧： getfacl,setfacl
    getfacl ：取得某个文件/目录的 ACL 设定项目。
    setfacl ：设定某个文件/目录的 ACL 规范。


     setfacl:
     setfacl [-bkRd] [{-m|-x} acl 参数] 目标文件名
     -m ：设定后续的acl参数给文件使用，不可与-x何用
     -x ：删除后续的acl参数，不可与-m何用
     -b ：移除【所有的】 ACL 设定参数
     -k ：移除【预设的】 ACL 参数，预设参数之后会介绍
     -R ：递归设定acl，亦即包括次目录都会被设定起来
     -d ：设定【预设 acl 参数】的意思！只对目录有效，在该目录新建的数据会引用此默认值。

     如何设定acl的特殊权限：
     针对单一使用设定者的设定方式：
     设定规范：【 u:[使用者账号列表]:[rwx] 】；
     例如：
     setfacl -m u:zcj:rx  file1

     。getfacl 指令用法
     getfacl filename


     。特定单一群组的权限设定：【g:群族名:权限】
     【 g:[群组列表]:[rwx] 】
     setfacl -m g:mygroup:rx file1
     基本上，群组与使用者的设定没有太大的差异。


     。针对有效权限设定：【 m:权限 】
     mask有点像是【有效权限】；使用者或群组所设定的权限必须要存在与mask的权限设定范围
     内才会生效，此即【有效权限】。即mask设定了在acl设定下的用户与群组的权限不得超过
     mask
     【 m:[rwx] 】

     。使用默认权限设定目录未来文件的 ACL 权限继承
     【 d:[u|g][user|group]:权限 】



13.4使用者身份的切换

     。使用一般账号：系统平日操作的好习惯
     。用较低权限启动系统服务
     。软件本身的限制


    13.4.1 su
    su是最简单那的身份切换指令：
    su [-lm] [-c 指令] [username]
    -  ：单纯使用 "-" 代表使用login-shell的变量文件读取方式来登入系统，
         若使用者名称没有加上去，代表切换为root
    -l ：与-类似，但后面必须加使用者账号。也是使用login-shell的方式登陆。
    -m ：-m与-p一样，表示使用目前的环境设定，而不读取新使用者的配置文件；
        不加"-" 也一样。
    -c ：仅进行一次指令然后返回原来的用户，所有-c后面可以加上指令。


    13.4.2 sudo
    sudo可以让你用其他用户的身份执行指令，通常是root。因此并非所有人都能够执行sudo，
    而是仅有规范到/etc/sudoers内的用户才能够执行sudo。

    。sudo指令的用法：
    由于系统默认仅有root可以执行sudo，因此我们要先规范。
    sudo [-b] [-u 新使用者账号]
    -b ：将后续的指令放到背景中让系统自行执行，而不与目前的shell产生影响。
    
    -u ：后面可以接欲切换的使用者。

    sudo的执行流程：
    .当用户执行sudo时，系统于/etc/sudoers文件中搜寻该使用者是否具有执行sudo的权限
    .若使用者具有可执行sudo的权限后，便让使用者【输入用户自己的密码】来确认
    .若密码输入成功后，便开始进行sudo后续接的指令
    .若欲切换的身份于执行者身份相同，那也不需要输入密码


    。visudo 与 /etc/sudoers
    除了root之外的其他账号，若想要使用sudo执行属于root的权限指令，则root需要先使用
    visudo去修改/etc/sudoers，让该账号能够使用全部或部分的root指令功能。
    为何不直接在/etc/sudoers里面修改？这是因为/etc/sudoers是有设定语法的，如果设
    定错误那会造成无法使用sudo的不良后果。

    ａ．单一用户可进行root所有指令，与sudoers文件语法：
    
    要让某人拥有sudo的权限，有两种做法:
    第一种是直接透过修改/etc/sudoers
    visudo 就可以修改，visudo本质是使用vi来修改该文件。
    修改的数据为：
    使用者账号 登入者的来源主机名=（可切换的身份）  可下达的指令
    root       ALL=(ALL)                          ALL
    还有一种方法让用户不需要输入密码：
    在可下达的指令哪里改成：NOPASSWD:ALL

    【使用者账号】：系统的哪个账号可以使用sudo指令
    【登入者的来源主机名】：当这个账号由哪个主机联机到本linux主机，意思是这个账号
    可能是由哪一部网络主机联机过来。
    【（可切换的身份）】：这个账号可以切换成什么身份来下达后续的指令
    【可下达的指令】：可用该账号下达什么指令。这个指令必须使用绝对路径撰写。
    ALL代表任何身份，主机，指令。

    b.第二种就是利用wheel群组以及免密码的功能处理visudo
    将/etc/sudoers里面的
    %wheel ALL=(ALL) ALL这一行的注释删掉
    最左边的%，代表后面接的是一个群组。
    这会使得【任何加入wheel这个群组的使用者，就能够使用sudo切换任何身份来操作任何
    指令】。当然也可以写入自己的群组。


    c.有限制的指令操作：
    如果我想要让用户仅能够进行部分系统任务，比如说，系统上面的fens尽能够帮root修改
    其他用户的密码时。
    可以这样：
    fens    ALL=(root)    /usr/bin/passwd
    
    但是我们给了fens这个权限后，它竟然可以修改root的密码！！！！
    因此我们要限制指令参数。可以改为：
    fens    ALL=(root)    !/usr/bin/passwd,/usrbin/passwd[A-za-z]*,
                          !/usr/bin/passwd root

    在前面加的【!】代表不可执行，因此上面这一行就变成不可执行【passwd】，可以执行
    【passwd　［A-Za-z］*】,不可以执行【 passwd root】

    d.通过别名建置visudo：
    如何大规模的添加用户进入sudo。透过别名：visudo的别名可以是【指令别名，账号别名，
    主机别名】等。这里仅介绍账户别名。
    假设我的fens,fen1,fen2要加入密码管理员的sudo列表中，那我们可以创建一个账户别名
    为CPDU，CPDCOMMAND的名称，然后将这个名称处理一下即可。
    
    CPDU=fens,fen1,fen2
    CPDCOMMAND=!/usr/bin/passwd,!/usr/bin/passwd root,/usr/bin/passwd [A-Za-z
    0-9]*
    CPDU   ALL=(root)    CPDCOMMAND

    顺带一提，这个账号名称一定要使用大写字符来处理，包括Cmnd_Alias（命令别名），
    Host_Alias（来源主机别名）都需要大写字符。


    e.sudo 的时间间隔问题：
    两次使用sudo的时间间隔在5分钟内，就不需要重新输入密码。


    f.sudo搭配su 的使用方式：
    ADMINS=u1,u2,u3,...
    ADMINS  ALL=(root) /bin/su -
    ADMINS里面的用户就会可以切换身份而且root密码不会外流。



13.5用户的特殊shell与PAM模块
  之前一直谈到的大多是一般身份用户与系统管理员的相关操作，而且大多是讨论关于可登入系统
  的账号来说。那如果我今天想要建立的，是一个【仅能使用 mail server 相关邮件服务的账号
  ，而该账号并不能登入 Linux 主机 】。如果不能给予该账号一个密码，那么该账号就无法使用
  系统的各项资源。而如果给予一个密码，那么该账号就可能可以登入 Linux 主机。
  /etc/login.defs 文件中，关于密码长度应该默认是5个字符串长度，但是这个设定值已经
  被 PAM 模块取代了。
  那么PAM是什么？


   13.5.1 特殊的shell，/sbin/nologin
   在/etc/passwd里面有一些系统账号，他们的shell就是使用/sbin/nologin，账号可以不用
   登入。这里是指这些账户无法使用baash等，或其他的shell来登入系统而已，还是可以使用
   其他的系统资源。
   假设Linux主机提供邮件服务，所以说在这个Linux的主机上面的账号，其实大部分都是用来收
   受主机的新建而已，并不需要登入主机。这个时候，我们已是考虑让单纯使用mail的账号以
   /sbin/nologin作为他们的shell，这样，最起码当我的主机被尝试想要登入系统以获得shell
   环境时，可以拒绝该账号。

   我们想要让某个具有/sbin/nologin的使用者知道，他们不能登入主机时，我们可以建立【
   /etc/nologin.txt】这个文件，并且在这个文件内说明不能登入的原因，那么下次，当该用
   户想要登入系统时，屏幕上就会出现/etc/nologin.txt这个文件的内容。


   13.5.2 PAM模块的简介
   在过去，我们想要对一个使用者进行认证（authentication），得要求用户输入账号密码，
   然后透过自行撰写的程序来判断该账号密码是否正确。也正因为如此，我们常常得使用不同
   的机制来判断账号，密码。所以一部主机上面拥有多个个别的认证系统，也造成账号密码可
   能不同步的验证问题。
   不过PAM（Pluggable Authentication Modules,嵌入式认证模块）的机制解决了这个问题。

   PAM 可以说是一套应用程序编程接口（Application Programming Interface,API），他
   提供了一连串的验证机制，只要使用者将验证阶段的需求告知PAM后，PAM就能够回报使用者
   验证的结果。
   由于PAM仅是一套验证的机制，所以可以提供给其他的程序使用，因此无论你是用什么程序，
   都可以使用PAM进行验证，如此一来，就能够让账号密码或是其他方式的验证具有一致性的
   结果。


   PAM 用来进行验证的数据称为模块（Modules），每个PAM模块的功能都不太相同。举例来说，
   当我们使用passwd指令时，如果随便输入字典上面找得到的字符串，passwd会回报错误信息。
   因为PAM的pam_cracklib.so 模块的功能。它能够判断改密码是否在字典里面，并回报给密码
   修改程序。pam_cracklib.so就是可以判断字符串是否在字典当中。

   13.5.3 PAM 模块设定语法
   PAM 藉由一个与程序相同文件名的配置文件来进行一连串的认证分析需求。我们以passwd这个
   指令呼叫PAM来说明。当我们执行了passwd后，呼叫PAM的流程是：

   a. 用户开始执行/usr/bin/passwd 这只命令，并输入密码；
   b. passwd呼叫PAM 模块进行验证；
   c. PAM 模块回到/etc/pam.d 找寻与程序（passwd）同名的配置文件；
   d. 根据/etc/pam.d/passwd 内的设定，引用相关的PAM模块逐步进行验证分析；
   e. 将验证结果回传给passwd这只程序；
   f. passwd 会根据PAM回传的结果决定下一个动作。

   查看/etc/pam.d/passwd
   可以看到每一行都是一个验证过程；
   第一栏：验证类别；   第二栏：控制标准；    第三栏：PAM 模块与该模块的参数。
   
   




