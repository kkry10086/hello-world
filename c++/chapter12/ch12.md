                         第十二章：
            使类对象像一个数值一样工作


c++内建类型的对象使用起来像一个数值一样：在对这种对象执行复制操作时，源对象与它的那个复件值内容一样，但它们是彼此独立的。改变其中任何一个对象都不会影响到另外一个对象。我们可以随意创建这种类型的对象，把它们作为参数传递给函数，作为函数的返回值，对他们进行复制，或者把它们赋值给其他的对象。

  那么对于自定义的类呢？
  当我们定义了自己的类时，我们就可以控制对类进行的扩展，使其对象可以像数值一样工作。

  在上一章中我们作的Vec类；
  在本章中我们将编写类似String类的一个简化版本，就叫做Str。我们将把注意力放在如何实现string具备的操作与转换功能上。这是建立在Vec的版本上面的。

12.1

   Str类中把管理数据的工作交给我们11章中写的Vec类。Vec类与我们要写的Str类功能非常相似；不过它还缺一个clear函数。

     这里还缺少析构函数还有复制构造函数或赋值运算符函数，这是因为Str类把管理内存的细节留给编译器，让编译器自动生成相应的函数，而这些函数有因为要对Vec类进行操作，所以会递归的调用Vec类的析构函数、复制构造函数、赋值运算符函数等。因此我们不用写。顺带一提，一个不需要析构函数的类也不需要显式的定义复制构造函数和赋值运算符函数。



12.2 自动转换
  至此，我们已经定义了一组构造函数并隐式地定义了复制、赋值和析构函数。这些操作的定义使得Str类对象使用起来像一个值：在我们复制一个Str类型对象的时候，源对象与其复制出来的对象彼此独立。接下来要考虑的是转换问题，c++自带的类型变量之间可以自动进行转换。

  在Str类中，我们定义了如何用一个const char*类型的参数来构造一个Str类型对象。所以可以写出下面的定义：
  Str s("hello");

  Str t="hello";
  s="hello";

  在这里我们使用的是char*类型，但是使用到的复制/赋值构造函数使用的参数是const Vec& rhs（自己看Vec类的代码）；因此我们会考虑为Str类添加一个参数类型为const char*的赋值运算符函数，并解决如何对复制构造函数进行重载的问题。
  而辛运的是，实际上我们并不需要这么做，因为我们已经有了一个带const char* 参数的构造函数，而且那个构造函数就像一个用户定义的转换一样工作。

  在类中定义类型转换包括两个方面的定义：把其他类型转换成该类类型，或者把该类类型转换成其他类型。第二种在12.5再谈。我们通过定义一个只带有一个参数的构造函数来定义类型转换。
  在Str类中已经有这样的一个构造函数，它带有一个const char*类型的参数。所以，编译器可以在需要一个Str类型的对象，但是程序提供的确实以恶搞const char*类型的对象时候调用这个构造函数。

  12.3 Str操作：
  在对于String的操作有：
  cin >> s
  cout<< s
  s[i]
  s1+s2
  上面几个运算符都是二元运算符。所以如果我们把它们定义成为函数，每个函数都应该有两个参数。如果是成员函数，那么其中一个参数可以是隐式被提供的。但是这样并不会像我们想象的那样工作。
  原因是：表达式中（cin >> s）的操作数（cin，s）与重载运算符函数（>>）的参数是如何紧密相关的。这里是指对于一个二元运算符函数（不是成员函数），其左操作数必须作为函数的第一个参数，右操作数必须作为函数的第二个参数。如果该运算符函数是成员函数，那么第一个参数总是默认地传递给该成员函数，也就是说第一个参数（左操作数）是使用该运算符函数的对象。

  例如：
  cin >> s就是 cin.operator >> (s)

  但是我们是在Str类里面将>>运算符函数作为成员函数来使用，那么此时就会变成：
  s.operator >>(cin) 同时： s>> cin

  这与我们平常使用语法的并不同样。

  所以我们最好将>>函数作为运算符函数，而不是成员函数。
  当然我们也不可能去修改istream头文件，也没有权限，更不应该去修改。

  所以，在Str类中：
  std::istream& operator >>(std::istream&,Str&);
  std:: ostream& operator << (std::ostream&,const Str&)

  输出运算符函数定义十分简单：它用一个迭代器遍历Str类中的每个元素，每次输出一个单个的字符：
  ostream& operator <<(ostream& os,const Str& s){
  for(Str::size_type i=0;i!=s.size();++i)
  {
      os<<s[i];
  }
  return os;
  }

  12.3.2 友员函数
  输入运算符比输出运算符难一点，因为我们要忽略开头的空格字符，然后连续地读字符并储存起来，知道遇到空格或者文件结尾标志。这里是简化版本：
  istream& operator >>(istream& is,Str& s){
   s.data.clear();
   char c;
   while(is.get(c)&&isspace(c)){}
   if(is){
     do s.data.push_back(c); //产生一个编译错误，因为data是私有成员数据
     while(is.get(c)&&!isspace(c));
   }
   return is;
  }

  这里使用get函数来获取下一个输入流的数据，而使用unget()就可以取消最近一次从输入流中读取一个字符的操作，输入流看上去就像没有调用过get函数一样。
  在这里无法使得文件编译通过，主要是因为这个>>运算符函数不是Str的成员函数，所以不能访问s的私有成员数据data。虽然可以增加getData函数来获取，但是仅仅如此还是不够的，我们还要向data变量中写入新的值。但是我们不希望谁都可以对data拥有写的权力。

  所以有更好的办法：就是把输入运算符函数声明为Str类的一个友员函数。友员函数拥有和成员函数一样的访问权力。通过把输入运算符函数声明为Str类的友员函数，我们赋予了该函数与该类的成员函数一样的对Str类私有成员数据的读写权力。
  class Str{
     friend std::istream& operator >> (std::istream&,Str&);
  };
  友员函数的声明可以加在类定义的任何一个地方：无论是private还是public都一样。因为友员函数具有特殊的访问权力，所以它是类接口的一部分。因此，一般在类声明的前面，public接口的附近，把所有的友员函数的声明放在一起作为一个相对独立的组。


  12.3.3 其他二元运算符
  接下来的工作是实现加好（+）运算符函数。和上面一样，我们应该考虑是否应该是成员函数，操作数（参数）是什么类型，该函数返回什么类型。
  首先我们希望连接的是Str类型的值，其次，不能改变原来两个操作数的值。没有要求一定要成为成员函数。
  s1+s2+s3
  要求返回的是Str类型的值。这些要求我们要把加好运算符实现成一个非成员函数。
  Str operator+(const Str& ,const Str&);
  如果我们提供了operator+函数，那么最好同时提供operator+=。也就是说，我们希望能够让用户用下面两种形式之一来链接s和s1，让后将结果付给变量s：
  s=s+s1;
  s+=s1;
  +=函数会改变s的，所以是可以作为成员函数的。
  Str& operator +=(cosnt Str& s){
    std::copy(s.data.begin(),s.data.end(),std::back_inserter(data));
    return *this;
  }

  之后+函数可以调用+=来完成：
  Str operator+ (cosnt Str& s,const Str& t){
  Str r=s;
  r+=t;
  return r;
}


  12.3.4混合类型表达式
  我们已经定义了链接运算符，它的操作数是const Str&类型的对象。如果表达式中包含字符指针（char *），那么如何？
  我们可以将char *转换成Str类型的数据，我们已经有写了，然后就可以使用之前的operator了。



   12.3.5 设计二元运算符
   在二元运算符的设计中参数转换的地位十分重要。如果一个类支持转换，那么把二元运算符定位成非成员函数是一个良好的习惯。这么做可以保证两个操作数的对称性。
   如果一个运算符函数是类的成员函数，那么这个运算符的做操作数不能是自动转换得到的结果。之所以有这样的限制，是因为当一个程序员在写像x+y这样的表达式的时候，编译器不会去对整个程序进行检测，以发现 把x转换成一个拥有成员operator+类型的可能性。因为这个限制，编译器不得不亲自检查作为非成员函数的operator+函数以及x类的operator+成员函数。



  12.4 有些转换是危险的
  在11.2.2中我们用关键字explicit修饰了一个带有一个大小参数的构造函数。我们假设没有把带有大小参数的构造函数声明为explicit。那么我们就可以隐式的生成一个指定大小的向量类型对象。在调用一个函数的时候我们可以隐式的进行转换。这两个一相加，我们可能得到的结果就不是我们想要的。
  一般来说，我们总是把定义将要被构造对象的结构的构造函数声明为expllicit。有些构造函数的参数最后会变成对象的一部分，这些构造函数一般就不必要被声明为explicit。

  12.5 类型转换操作函数
  在12.2中，我们看到有些构造函数也定义了转换操作。类的编写者们可以定义显式地类型转换操作，该操作定义了如何把一个对象从原来的类型转换成一个希望得到的类型。
  要求：转换操作必须定义成类的成员函数。转换操作函数的函数名为operaror加上目标类型名。因此，如果一个类有一个名为operator double的成员函数，这个成员函数可以用来把一个该类类型的变量转换成double类型的变量：
  class Student_info{
  public:
    operaotr double();

  };
  这里定义了如何把Studnet_info类的对象转换成一个double类型的变量。这种转换的具体意义依赖于操作函数的具体定义。在需要一个double类型的值的地方，程序提供的确实一个Student_info类型对象，这时候编译器自动调用这个转换操作函数。例如：
  Vector<Student_info> vs;
  double d=0;
  for(int i=0;i!=vs.size();++i)
  d+=vs[i];

  cout<<"Average grade:"<<d/vs.size()<<endl;
  转换操作函数在把一个自定义类型转换成一个c++内建的类型的时候经常被调用，有时也可以用它来把一个类的类型转换成另一个我们没有代码的类的类型。在两种情况下，我们都不能往目标类中加入构造函数，因此我们只能在我们拥有代码的类中把转换函数定义为类的一部分。

  事实上，在我们写的每一个隐式地检测istream的值的循环中，都调用了这类转换操作函数。
  if(cin>>x)
  等效于
  cin>>x
  if(cin)

  现在我们要理解上面表达式后面发生了些什么事：
  我们知道if语句对一个条件语句进行判断，该语句生成一个值。这里可以判断数学类型，或者指针类型，但是iostream不是指针也不是数学类型。但是，在标准库中定义了一个从iostream类型到void*类型的转换，而void*是一个指向void类型的指针。

  在之前我们还没使用过void*类型，void类型有几种用途：最基本的用途是作为一个指针指向的类型。一个指向void的指针有时候又叫做通用指针。因为这是一个可以指向任何类型对象的指针。
  当然，不能对这个指针间接引用，因为它指向的对象的类型还是未知。不过我们可以把指针类型转换成bool类型。
  因此istream类被定义为operator void*而不是operator bool，这是为了让编译器可以检测下面的错误用法：
  int x;
  cin <<x;


  12.6 类型转换与内存管理
  这次是Str类转换到char*。
  很多系统都是用c语言或者汇编语言来编写，这些语言都是以空字符结尾。而c++也沿用了这些惯例。我们要把Str类转换为char*，但是这样做充满了内存管理上的缺陷。

  public：
  operator char*();
  operator const char*()const;

  Str的用户可能写出下面的代码：
  Str s;
  ifstream in(s);

  上面的代码几乎不可能正确得完成转换。显然我们需要一个字符数组类型的数据，而程序提供的是我们自定义的Vec<char>的数据。而且就算类型匹配了，我们也不希望返回data，这会违反Str类的封装性：这个data的指针可以被获取，用户可能会使用该这阵改变string的值等等我们不希望发生的事。
  为了解决后面
  p249这里不写了自己看。



这里的习题，以后再说；





  