10.1指针与数组：

使用指针时，可以有两种写法：
int *p
int* p
这两种写法中后面一种有一个极大的缺陷，
例如：
int* p,q;定义实际上是p是指向int型的指针而q定义成一个整形变量；
与c语言不一样，容易造成歧义。
所以建议使用的时候，int *p,*q;

间接引用函数：
由于一个函数所能做的所有操作只能是获得它的地址或调用它。所以在任何地方出现一个函数名而且不是在调用该函数时，即使没有显式地使用&声明，编译器都会将它解释成为该函数的地址。
例如：
int next(int n){
    return n+1;
}

int (*fp)(int)

此时fp指向函数时：
fp=&next;
fp=next; 是相等的。


使用fp时：
i=(*fp)(i);
i=fp(i);这两种都行。
这里可以理解为，由于编译器把函数名解释为地址，因此可以直接使用地址类型的fp直接调用函数。

如果我们想要写一个返回类型为指向函数的指针的函数，其必须显式地声明该函数返回会一个指针，一种实现方式就是：先使用关键字typedef定义函数名(annalysis_fp)为一个合适的指针类型的类型名。

例如：
typedef double (*analysis_fp) (const vector<Student_info>&);
然后可以用该类型来声明我们的新函数：
analysis_fp get_analysis_ptr();
//get_analysis_ptr函数的返回值为一个指向analysis函数的指针。
double (*get_analysis_ptr()) (const vector<Student_info>& );



10.1.3数组：
数组是容器的一种，但它是核心语言的一部分，而不是标准库的内容。每个数组都包含一个或几个同类型的对象，每一个对对象称之为一个元素。且要求元素个数在编译时就要确认。可以看作为c里面的z数组。
因为数组不是类，所以没有成员函数和成员变量。所以数组没有size_type这个成员变量，所以无法利用成员变量命名一个合适的类型来处理数组尺寸的问题。取而代之，它在<cstddef>头文件中定义了一个更普遍的类型size_t。size_t被定义为无符号类型，其a大小足以装下任何对象。因此我们必须使用size_t来表示一个数组的大小，就像在容器中我们使用size_type来表示容器大小一样。
数组的定义和c语言里面的一样,一个三维集合点的定义：
double coords[3];
如果你知道物理空间里的维数是不会随时间变化的，那么就可以对三位集合点写出一种更好的定义。
const size_t NDim = 3;
double coords[NDim];
无论我们如何定义一个数组，在数组与指针之间都有一个基本的关系：只要我们将数组名作为一个值来使用，那么数组名将表示指向数组首元素的指针，换言之，数组名保存了该数组的首地址。而此时数组名就类似指针了。

10.1.4 指针算法：

指针是一种迭代器，或者确切地说，指针是一个随即存储的迭代器。

将coords的内容复制到一个向量中。
vector<double> v;
copy(coords,coords+NDim,back_inserter(v));