10.1指针与数组：

使用指针时，可以有两种写法：
int *p
int* p
这两种写法中后面一种有一个极大的缺陷，
例如：
int* p,q;定义实际上是p是指向int型的指针而q定义成一个整形变量；
与c语言不一样，容易造成歧义。
所以建议使用的时候，int *p,*q;

间接引用函数：
由于一个函数所能做的所有操作只能是获得它的地址或调用它。所以在任何地方出现一个函数名而且不是在调用该函数时，即使没有显式地使用&声明，编译器都会将它解释成为该函数的地址。
例如：
int next(int n){
    return n+1;
}

int (*fp)(int)

此时fp指向函数时：
fp=&next;
fp=next; 是相等的。


使用fp时：
i=(*fp)(i);
i=fp(i);这两种都行。
这里可以理解为，由于编译器把函数名解释为地址，因此可以直接使用地址类型的fp直接调用函数。

如果我们想要写一个返回类型为指向函数的指针的函数，其必须显式地声明该函数返回会一个指针，一种实现方式就是：先使用关键字typedef定义函数名(annalysis_fp)为一个合适的指针类型的类型名。

例如：
typedef double (*analysis_fp) (const vector<Student_info>&);
然后可以用该类型来声明我们的新函数：
analysis_fp get_analysis_ptr();
//get_analysis_ptr函数的返回值为一个指向analysis函数的指针。
double (*get_analysis_ptr()) (const vector<Student_info>& );



10.1.3数组：
数组是容器的一种，但它是核心语言的一部分，而不是标准库的内容。每个数组都包含一个或几个同类型的对象，每一个对对象称之为一个元素。且要求元素个数在编译时就要确认。可以看作为c里面的z数组。
因为数组不是类，所以没有成员函数和成员变量。所以数组没有size_type这个成员变量，所以无法利用成员变量命名一个合适的类型来处理数组尺寸的问题。取而代之，它在<cstddef>头文件中定义了一个更普遍的类型size_t。size_t被定义为无符号类型，其a大小足以装下任何对象。因此我们必须使用size_t来表示一个数组的大小，就像在容器中我们使用size_type来表示容器大小一样。
数组的定义和c语言里面的一样,一个三维集合点的定义：
double coords[3];
如果你知道物理空间里的维数是不会随时间变化的，那么就可以对三位集合点写出一种更好的定义。
const size_t NDim = 3;
double coords[NDim];
无论我们如何定义一个数组，在数组与指针之间都有一个基本的关系：只要我们将数组名作为一个值来使用，那么数组名将表示指向数组首元素的指针，换言之，数组名保存了该数组的首地址。而此时数组名就类似指针了。

10.1.4 指针算法：

指针是一种迭代器，或者确切地说，指针是一个随时存储的迭代器。

将coords的内容复制到一个向量中。
vector<double> v;
copy(coords,coords+NDim,back_inserter(v));

10.1.5 索引：
与c语言一样；

10.1.6数组初始化：
使用为数组的每个元素初始化的语法可以避免显式地定义该数组的大小。
例如：
const int month_length[]={31,28,31,30,31,30,31,30,31,30,31,30};


10.2 字符串常量
字符串常量是一个字符常量数组，该数组的大小是字符串的长度加一。这多出来的一个字符是编译器自动在其他的字符后面加上的一个空字符('\0')。
例如：
const char hello[]={'H','e','l','l','o','\0'};
等价于 const string hello="Hello"。

编译器向字符串常量末尾加入一个空字符('\0')，是作为该字符串的终止符。要知道一个字符串变量只给出该变力量手自负的地址，程序在一个字符串中遇到第一个空字符时认为字符串结束。

在<cstring>库函数中有一个函数叫做strlen，可以用来求一个字符串变量或者一个空字符串结束的数组的大小。但是strlen不会返回空字符这个终止符。

10.5.2处理多个输入输出文件：
在定义一个ifstream类型对象或者一个ofstream类型对象的时候，可能会要求提供一个string类型形式的文件名。事实上，C++要求的不是一个string类型对象，而是一个指向以空字符结尾的字符数组的首元素的指针。原因：
  一、这种方式可以让程序用到输入 ———输出库的特性而不依赖string类的特性；
  二、输入输出库的出现比string类要早很久；
  三、以这种方式提供文件名的时候可以使程序更易于与操作系统的输入输出函数之间建立接口，一般来说它们都是通过指针来通信的。
  如果要使用string类，那么就要四用c_str成员函数；
  例如：ifstream infile(s.c_str());


10.6三种内存分配方法：

第一种：自动分配内存：
这种方法常与局域变量联系在一起：一个局域变量只在程序执行到该变量定义的时候才由系统自动分配内存给它，当包含该变量的定义的模块结束时，该变量占用的内存自动释放。当结束时，如果其被定义为静态(static)变量，其占用的内存不会释放，会在程序结束时，才会被释放。

然而，静态分配内存存在潜在的危机，因为每次对一个指向一个静态变量的指针的调用都返回指向同一个对象的指针。但是我们要返回的是新的对象的指针，而为了达到这个目的，我们使用动态分配内存的方法，我们使用new和delete这两个关键字。


10.6.1为一个对象分配/释放内存：
如果T是一个对象的类型，那么new T表达式将为一个T类型的对象分配内存，该变量由构造函数对其初始化，并且产生一个指向该新分配内存的对象（该对象甚至没有命名）的指针。执行像new T(args)这样的初始化语句可以给变量赋予一个特定的值。该对象一直存在直至程序结束或者执行了delete p语句，其中p是在new语句中返回的一个指针。为了用delete删除一个指针，这个指针必须是指向一个用new语句分配内存的对象，或者是一个零指针。删除一个零指针不进行任何操作。
int *p=new int(42);
delete p;
这个语句将*p对象占用的内存空间释放出来，p将是一个无效指针，在我们将一个新的值赋给它之前p具有不可预知的值。

10.6.2 为一个数组分配/释放内存

如果T是一个类型名，而n是一个非负整数，那么new T[n]语句将为一个n个T类型对象的数组分配内存，并且返回一个指向数组首元素的指针（该指针类型为T*）。每个对象都将被默认初始化，也就是说如果T是内建类型而且数组又只是在局部作用域内分配内存，那么对象将不会被初始化。如果T是一个类，那么数组中的每个元素都会运行类的缺省构造函数进行初始化。
如果T是一个自定义类型，那么在初始化的过程中有两点要注意：
一、如果该类不允许默认初始化，那么编译器将终止程序；
二、数组中n个元素的每一个元素都会被初始化，这将带来一定的运行时开销。11章会讲另一种为数组动态分配内存的更加灵活的机制，该分配方法有标准库来提供。

一个数组要求至少有一个元素，但是当new T[n]中的n==0时，那么在数组中将包含任何元素。当发生这种情况时，new函数无法返回一个指向首元素的指针，因为数组根本没有元素。而事实上new函数此时会返回一个有效但无意义of-the-end的指针，我们可以把它作为delete[]的参数使用，我们还可以把它想象成一个指向首元素的指针。
这实质是为了允许n等于0时仍能执行。
T* p=new T[n];
vector<T> v(p,p+n);
delete[] p;
delete 旁边的[]是告知系统释放整个数组占用的内存，而不仅仅是释放其中一个元素的内存。一个数组一旦用new[]分配了内存，那么该内存将一直被使用知道程序终止或者执行了delete[] p语句。在释放数组之前，系统根据相反的顺序逐个释放数组中的每个元素。

一个复制字符数组的程序。

char * duplicate_chars(const char *p)
{
        //allocate enough memory especially '\0'
        size_t length=strlen(p)+1;
        char *result =new char[length];
        std::copy(p,p+length,result);
        return result;
}

