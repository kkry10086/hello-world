# 继承与构造函数

我们在必须理解编译器是如何生成一个派生类的。派生类的对象在构造的时候经过以下步骤：

1.为整个对象分配内存空间（包括基类中与派生类中定义的数据）
2.调用基类的构造函数以初始化对象中的基类部分数据
3.用构造初始化器对对象的派生类部分数据进行初始化
4.如果有的话，执行派生类构造函数的函数体

唯一的一个新内容是如何选择调用基类的哪一个构造函数。


## 13.2 多态和虚拟函数

### 13.2.1虚拟函数：
我们希望系统根据**实际传输给函数的参数**的类型来运行正确的函数，而参数的类型只有到运行的时候才是已知的。
而为了支持这种运行时选择，c++提供了虚拟(virtual)函数。

```
Class Core{
      public: virtual double grade() cosnt;
}

```
这样就完成了。此时grade就是一个虚拟函数。此时调用
```
bool compare(const Core& a,const Core& b){
    return a.grade()<b.grade();
}
```

程序在执行时将由**参数的实际类型**来决定调用哪个grade函数。如果是Grad就用Grad的grade函数，如果是Core的就用Core的grade来执行。

virtual关键字只能在类的定义里被使用。如果类中一个函数是虚拟的，那么在派生类中他的虚拟特性也会被继承。

---

### 13.2.2动态绑定

只有在以引用或者指针为参数调用**虚拟函数**的时候，它(指的是虚拟函数)的运行时选择特性才会有意义。

**这里有两个问题：**
```
一是由对于哪个对象的函数的引用的问题，二是对于引用对象的函数的参数类型的问题。
一的问题由虚拟函数来解决，二是由动态绑定来解决
```

**原因**：
如果我们以对象的名义调用一个虚拟函数，那我们就可以在编译的时候知道对象的类型，对象的类型一旦确定了，即使在运行时也不会改变了。
相反的，一个指向基类对象的引用或指针可能确实是指向一个基类对象，也可能是指向该基类派生出来的对象，也就是说，无法在编译阶段确定指针的类型。因此引用或者指针指向的对象的实际类型在运行时才会确定。

**对于引用或者指针的（可以变化的）调用就是动态绑定。
而对于对象的（不可变化的）调用就是静态绑定。**

在要求一个指向基类对象的指针或引用的地方，我们却可以用一个指向派生类的指针或引用来代替。
这时OOP中的一个关键概念：**多态性(polymorphism)**。

在通过以一个指针或者一个引用虚拟函数的时候，我们实际上就在进行一个多态的调用。
引用或者指针**参数**的类型是固定的，但是参数所引用或者指针所指的**对象**的类型却可以是所指（或所引）对象的类型，或者是由该类派生出来的任何一个子类。

## 13.3用继承解决问题

**这里的知识有用，之后记得写下来。
最重要的：
为何模版函数不能使用动态绑定：
模版函数要求在链接时就确定好类型，而动态绑定要到运行时才能够确定类型。这时程序一定会报错。**


### 13.3.2虚拟析构函数

现在我们的程序基本上可以正常运行了。现在只剩下一个问题，当我们删除对象的时候，因为我们在分配对象时使用的是Core*类型指针，而不是Grad*类型指针，即使指的是一个Grad类型对象的时候也是如此。这时，我们调用的析构函数就有可能是Core的也可能是Grad（之前没有定义为虚拟函数）。

**delete**的时候发生了两件事：
1.调用了指针所指对象的析构函数；
2.对象所占用的内存空间被释放回系统；

这些问题都可以通过虚拟的机制来解决。为了得到一个虚拟的析构函数，我们要在类中显示的定义一个析构函数，在把它定义为虚拟函数。


## 13.4一个简单的句柄类

前面为了能够使基类与派生类都能够使用同样的函数来做同一件事。使用了大量的动态绑定，即大量的指针，也因此引用了太多的复杂性，同时也引入一些可能导致错误的缺陷。

我们必须记得去分配空间与删除空间，但是也完成了工作。

而这里就要说一种全新的办法，使得写出来的程序既可以保持简洁性又不会产生太多的复杂的问题。
因此可以使用一个普遍的编程技巧――句柄类(handle class);

**句柄类：**
写一个新的类封装这个指向Core类型对象的指针，这样就把隐患在用户面前藏了起来。
这些隐患就是我们每次使用Core指针的时候，都要花费多的注意力在生成与删除这个指针上。
句柄类就是为了来解决这些问题的。

##### **静态成员函数**
与一般成员函数不同，静态成员函数不能对类的对象进行操作。和其他的成员函数不同的是，
静态成员函数与类关联，而不是与一个特定的类型对象关联。
类似java的static。
就是在进程运行时，一开始就会放在数据块，不是栈也不是堆。



### 13.4.2复制句柄对象


    这里是用于Student_info复制构造函数用的，因为Student_info的复制构造函数
    的参数仅仅是一个指针，谁知道是谁的。
    但是有虚拟函数，所以我们可以通过生成一个虚拟函数，然后由这个函数返回本身的类型
    这样就行了。
    
    这里的Core(*this)就是一个复制构造函数，是由编译器自动生成给我们的
    下面的protected类型，就表示了这是受保护的，但是派生类可以继承的函数
    这样就表示Student_info无法调用这个函数。
    但是之前学过友员函数，其实也有友员类，只要将Student_info定义为
    友元类就可以访问了。
    
    那么我们为何不把这个函数定义为public类型？
    因为这个函数仅仅是用于Student_info的复制构造函数上，实际上对于用户来说，
    并不需要直接调用它。所以不建议用public。


```
    protected:
    virtual Core* clone(){
        return new Core(*this);
    }  
```

#### 继承

友员函数或者类是无法被继承的，而派生类不需要写友员关系是因为，只需要通过调用Core::
clone函数的虚拟调用来间接调用派生类的虚拟函数。


## 13.6微妙之处

**这里值得一看，有用**