# 继承与构造函数

我们在必须理解编译器是如何生成一个派生类的。派生类的对象在构造的时候经过以下步骤：

1.为整个对象分配内存空间（包括基类中与派生类中定义的数据）
2.调用基类的构造函数以初始化对象中的基类部分数据
3.用构造初始化器对对象的派生类部分数据进行初始化
4.如果有的话，执行派生类构造函数的函数体

唯一的一个新内容是如何选择调用基类的哪一个构造函数。


## 13.2 多态和虚拟函数

### 13.2.1虚拟函数：
我们希望系统根据**实际传输给函数的参数**的类型来运行正确的函数，而参数的类型只有到运行的时候才是已知的。
而为了支持这种运行时选择，c++提供了虚拟(virtual)函数。

```
Class Core{
      public: virtual double grade() cosnt;
}

```
这样就完成了。此时grade就是一个虚拟函数。此时调用
```
bool compare(const Core& a,const Core& b){
    return a.grade()<b.grade();
}
```

程序在执行时将由**参数的实际类型**来决定调用哪个grade函数。如果是Grad就用Grad的grade函数，如果是Core的就用Core的grade来执行。

virtual关键字只能在类的定义里被使用。如果类中一个函数是虚拟的，那么在派生类中他的虚拟特性也会被继承。

---

### 13.2.2动态绑定

只有在以引用或者指针为参数调用**虚拟函数**的时候，它(指的是虚拟函数)的运行时选择特性才会有意义。

**这里有两个问题：**
```
一是由对于哪个对象的函数的引用的问题，二是对于引用对象的函数的参数类型的问题。
一的问题由虚拟函数来解决，二是由动态绑定来解决
```

**原因**：
如果我们以对象的名义调用一个虚拟函数，那我们就可以在编译的时候知道对象的类型，对象的类型一旦确定了，即使在运行时也不会改变了。
相反的，一个指向基类对象的引用或指针可能确实是指向一个基类对象，也可能是指向该基类派生出来的对象，也就是说，无法在编译阶段确定指针的类型。因此引用或者指针指向的对象的实际类型在运行时才会确定。

**对于引用或者指针的（可以变化的）调用就是动态绑定。
而对于对象的（不可变化的）调用就是静态绑定。**

在要求一个指向基类对象的指针或引用的地方，我们却可以用一个指向派生类的指针或引用来代替。
这时OOP中的一个关键概念：**多态性(polymorphism)**。

在通过以一个指针或者一个引用虚拟函数的时候，我们实际上就在进行一个多态的调用。
引用或者指针**参数**的类型是固定的，但是参数所引用或者指针所指的**对象**的类型却可以是所指（或所引）对象的类型，或者是由该类派生出来的任何一个子类。

## 13.3用继承解决问题

**这里的知识有用，之后记得写下来。
最重要的：
为何模版函数不能使用动态绑定：
模版函数要求在链接时就确定好类型，而动态绑定要到运行时才能够确定类型。这时程序一定会报错。**



