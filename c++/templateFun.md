一、模板的关键概念：
  1.不同类型的对象任然可以享有相同的行为特征。
模板参数让我们可以按照共同的行为特性来编写程序--
即使在定义模板的时候我们并不知道与模板参数相对应的特定的类型。
在使用一个模板的时候我们确实地知道这些的类型。

二、泛型函数：
  1.实现泛型函数的语言特征被称作模板函数。模板函数可以让我们为一个行为特征相似的函数族
  （类型族）编写一个单独的含义。我们把族中各个函数（类型）的差异归因与他们的模板参数的
  类型不同。

  2.对于泛型函数，系统环境无需对那些在运行期间类型会变化的对象做什么样的处理动作做考虑，
  只需要在编译期间考虑这个问题。即（泛型函数的类型参数的类型确定是在编译期间决定的）。


  3.类型参数的操作方式与函数参数类似，他们定义了可以在函数作用域内使用的名称。不过，类型
  参数表示类型而不是表示变量。▲无论类型参数出现在哪里，系统环境都会认为其命名了一个类型
  。
  e.g.T:类型参数。
  vector<T> 是类型，vector<T>::size_type 是类型，vector<T>::interator也是类型。


三、模板实例化;
  c++标准并没有说明系统环境是如何处理模板的实例化，因此，所有的系统环境都会以它自己
  的方式去处理实例化。
  1、在编辑-编译-链接的模式的系统环境下，实例化一般发生在链接过程。只有
  模板被实例化了，系统环境才能证实，模板代码能被用于指定的类型。因此，在连接期间按，我们
  就可以发现那些看起来在编译期间可能发生的错误。（我也不懂，没用过编译，链接的命令。猜测
  是类型对不上的错误）。


  2、为了对一个模板进行实例化，（实例化是由系统环境来实行的）当前的大多数系统环境都要求
  这个模板的定义（不仅仅是声明）必须是系统环境是可以访问的，


四、算法与迭代器：
  5种迭代器：每一种都对应于一个特定的迭代器操作集合。这些迭代器中国类划分了每一个库
  容器提供的迭代器的类别。每一个标准算法都表示了它期望的是哪些种类的迭代器参数。

  1、输入迭代器：支持++，==，！=，*，->，的操作的迭代器。
  2、输出迭代器：与输入迭代器有一点不同：不能够在对*it的两个赋值运算之间执行超过一次的
  ++it的操作。同时，我们也不能在没有对it进行递增的情况下对it多次赋值。
  3、正向迭代器：满足输入，输出迭代器的要求，但有一点不同，即可以对通过一个it进行多次的
  赋值。
  4、双向迭代器：既满足正向迭代器，又可以使用--操作。
  5、随机迭代器：包含双向迭代器，同时支持算术运算，（p+n,p-n,p[n],p<q,p>q,p==q）


五、迭代器区间和越界值(capacity.end())
  指向容器区间的两个迭代器，其中代表end的迭代器为何指向我们所要的区间的最后位置的后面一
  个位置。
  reason:
  1、如果区间没有元素，那我们就找不到最后一个元素来标记终点。使用时，end就会指向一个空的
  区间。而且end会指向哪里？指向的是原来end指前的位置的话，就会指向begin(null)之前。

  2、我们用end来指向最后元素后面的位置，我们就可以仅仅去判定相等或不相等来比较迭代器。
  而且，当两个迭代器相等时，即代表了容器长度为0。

  3、我们这样就可以用一种自然的方式来表示"区间之外"。许多的标准库算法都是利用了这个end，
  使用它来代表指示失败。
  
